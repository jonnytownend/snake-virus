// Auto-generated by scripts/generate-source-corpus.mjs
// Do not edit manually.

export const SOURCE_CORPUS = [
  {
    "path": "jest.config.js",
    "content": "export default {\n  testEnvironment: \"node\",\n  watchman: false,\n  roots: [\"<rootDir>/tests\"],\n  testMatch: [\"**/*.test.js\"],\n  collectCoverageFrom: [\n    \"src/game/constants.js\",\n    \"src/game/game-state.js\",\n    \"src/game/grid.js\",\n    \"src/game/syntax-highlighter.js\",\n    \"src/game/game-engine.js\"\n  ],\n  coverageReporters: [\"text\", \"lcov\", \"html\"],\n  coverageThreshold: {\n    global: {\n      statements: 85,\n      branches: 80,\n      functions: 85,\n      lines: 85\n    }\n  }\n};\n"
  },
  {
    "path": "src/game/audio-engine.js",
    "content": "export class AudioEngine {\n  constructor(onStatusChange = () => {}) {\n    this.onStatusChange = onStatusChange;\n    this.enabled = false;\n    this.playbackActive = false;\n    this.speedMultiplier = 1;\n    this.audioCtx = null;\n    this.musicTimer = null;\n    this.musicStep = 0;\n    this.notifyStatus();\n  }\n\n  isEnabled() {\n    return this.enabled;\n  }\n\n  async toggle() {\n    if (this.enabled) {\n      this.disable();\n      return;\n    }\n\n    await this.enable(true);\n  }\n\n  async ensureEnabledForGameplay() {\n    if (this.enabled) return;\n    await this.enable(false);\n  }\n\n  setPlaybackActive(active) {\n    this.playbackActive = active;\n    if (this.playbackActive) {\n      this.startMusic();\n      return;\n    }\n    this.stopMusic();\n  }\n\n  setGameSpeed(multiplier) {\n    this.speedMultiplier = Math.max(1, Number(multiplier) || 1);\n    if (this.musicTimer) this.restartMusic();\n  }\n\n  playStartSfx() {\n    this.playTone({ freq: this.noteToHz(64), duration: 0.06, type: \"square\", gain: 0.02 });\n    this.playTone({\n      freq: this.noteToHz(71),\n      duration: 0.08,\n      type: \"square\",\n      gain: 0.02,\n      when: 0.06\n    });\n  }\n\n  playEatSfx() {\n    this.playTone({ freq: this.noteToHz(76), duration: 0.07, type: \"triangle\", gain: 0.025 });\n    this.playTone({\n      freq: this.noteToHz(83),\n      duration: 0.09,\n      type: \"triangle\",\n      gain: 0.018,\n      when: 0.03\n    });\n  }\n\n  playCrashSfx() {\n    this.playTone({ freq: this.noteToHz(42), duration: 0.24, type: \"sawtooth\", gain: 0.03 });\n  }\n\n  dispose() {\n    this.disable();\n  }\n\n  async enable(withToggleChime) {\n    this.ensureContext();\n    if (!this.audioCtx) return;\n\n    if (this.audioCtx.state === \"suspended\") {\n      await this.audioCtx.resume();\n    }\n\n    this.enabled = true;\n    if (this.playbackActive) this.startMusic();\n\n    if (withToggleChime) this.playStartSfx();\n    this.notifyStatus();\n  }\n\n  disable() {\n    this.enabled = false;\n    this.stopMusic();\n    this.notifyStatus();\n  }\n\n  notifyStatus() {\n    this.onStatusChange(this.enabled);\n  }\n\n  ensureContext() {\n    if (this.audioCtx) return;\n\n    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContextCtor) return;\n\n    this.audioCtx = new AudioContextCtor();\n  }\n\n  noteToHz(midi) {\n    return 440 * 2 ** ((midi - 69) / 12);\n  }\n\n  playTone({ freq, duration = 0.1, type = \"square\", gain = 0.04, when = 0 }) {\n    if (!this.enabled || !this.audioCtx) return;\n\n    const startTime = this.audioCtx.currentTime + when;\n    const oscillator = this.audioCtx.createOscillator();\n    const envelope = this.audioCtx.createGain();\n\n    oscillator.type = type;\n    oscillator.frequency.value = freq;\n\n    envelope.gain.setValueAtTime(0.0001, startTime);\n    envelope.gain.exponentialRampToValueAtTime(gain, startTime + 0.01);\n    envelope.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);\n\n    oscillator.connect(envelope);\n    envelope.connect(this.audioCtx.destination);\n\n    oscillator.start(startTime);\n    oscillator.stop(startTime + duration + 0.02);\n  }\n\n  startMusic() {\n    if (!this.enabled || !this.audioCtx || !this.playbackActive || this.musicTimer) return;\n\n    const bass = [40, 40, 43, 45, 40, 40, 47, 45];\n    const lead = [64, 67, 71, 69, 67, 64, 62, 59];\n    const beatMs = Math.max(100, Math.round(260 / this.speedMultiplier));\n\n    this.musicStep = 0;\n    this.musicTimer = setInterval(() => {\n      const index = this.musicStep % bass.length;\n      this.playTone({\n        freq: this.noteToHz(bass[index]),\n        duration: 0.22,\n        type: \"triangle\",\n        gain: 0.015\n      });\n      this.playTone({\n        freq: this.noteToHz(lead[index]),\n        duration: 0.11,\n        type: \"square\",\n        gain: 0.011,\n        when: 0.03\n      });\n      this.musicStep += 1;\n    }, beatMs);\n  }\n\n  stopMusic() {\n    if (!this.musicTimer) return;\n\n    clearInterval(this.musicTimer);\n    this.musicTimer = null;\n  }\n\n  restartMusic() {\n    if (!this.enabled || !this.playbackActive) return;\n    this.stopMusic();\n    this.startMusic();\n  }\n}\n"
  },
  {
    "path": "src/game/constants.js",
    "content": "export const TARGET_SEQUENCE = [\n  \"{\",\n  \"}\",\n  \"(\",\n  \")\",\n  \"[\",\n  \"]\",\n  \";\",\n  \"=\",\n  \"<\",\n  \">\",\n  \"a\",\n  \"e\",\n  \"i\",\n  \"o\",\n  \"u\",\n  \"s\",\n  \"r\",\n  \"t\",\n  \"n\",\n  \"l\",\n  \"c\",\n  \"d\",\n  \"m\",\n  \"f\"\n];\nexport const HAZARD_SEQUENCE = [\n  \":\",\n  \".\",\n  \",\",\n  \"\\\"\",\n  \"'\",\n  \"`\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\"\n];\n\nexport const CORRUPTION_CHARS = [\n  \"#\",\n  \"@\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"?\",\n  \"!\",\n  \"+\",\n  \"=\",\n  \"~\",\n  \"$\",\n  \"^\",\n  \"/\",\n  \"\\\\\",\n  \"|\",\n  \"<\",\n  \">\",\n  \"_\"\n];\nexport const KEYWORDS = new Set([\n  \"const\", \"let\", \"var\", \"function\", \"return\", \"if\", \"else\", \"for\", \"while\",\n  \"class\", \"new\", \"true\", \"false\", \"null\", \"undefined\", \"switch\", \"case\",\n  \"break\", \"continue\", \"try\", \"catch\", \"finally\", \"import\", \"from\", \"export\"\n]);\n\nexport const GRID = Object.freeze({\n  width: 72,\n  height: 30\n});\n\nexport const TARGETS = Object.freeze({\n  minChars: 2,\n  maxChars: 4,\n  charGrowthStep: 22,\n  perCharBase: 8,\n  perCharMax: 20,\n  perCharScoreStep: 120,\n  baseQuota: 8,\n  maxQuota: 20,\n  scoreStep: 70\n});\n\nexport const HAZARDS = Object.freeze({\n  unlockAtEaten: 8,\n  baseCount: 4,\n  growthStep: 6,\n  maxCount: 100\n});\n\nexport const SPEED = Object.freeze({\n  baseDelayMs: 180,\n  minDelayMs: 60,\n  maxMultiplier: 2.75,\n  increasePerEat: 0.03\n});\n\nexport const STAGES = Object.freeze({\n  corruptionsPerLevel: 10\n});\n\nexport const START_DIRECTION = Object.freeze({ x: 1, y: 0 });\n\nexport const UI_TEXT = Object.freeze({\n  ready: \"Press Space to unleash Snake Virus.\",\n  fullCorruption: \"System fully corrupted. Press Space to replay.\",\n  fullCorruptionReset: \"System fully corrupted. Press Space to run again.\",\n  crash: \"Virus crashed. Press Space to re-run.\",\n  playerCrash: \"Virus collided with another player. You were ejected from this room.\",\n  hazardCrash: \"Virus hit protected code. Press Space to re-run.\",\n  corruptionCrash: \"Virus consumed corrupted code. Press Space to re-run.\"\n});\n"
  },
  {
    "path": "src/game/game-engine.js",
    "content": "import {\n  CORRUPTION_CHARS,\n  GRID,\n  HAZARDS,\n  HAZARD_SEQUENCE,\n  KEYWORDS,\n  SPEED,\n  STAGES,\n  TARGET_SEQUENCE,\n  TARGETS,\n  UI_TEXT\n} from \"./constants.js\";\nimport { createInitialState } from \"./game-state.js\";\nimport {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"./grid.js\";\nimport { buildStyleGrid } from \"./syntax-highlighter.js\";\n\nfunction asSourceProvider(sourceProvider, sourceText) {\n  if (sourceProvider && typeof sourceProvider.nextSource === \"function\") {\n    return sourceProvider;\n  }\n\n  return {\n    nextSource: () => sourceText || \"\"\n  };\n}\n\nexport class GameEngine {\n  constructor({ renderer, audio, sourceProvider, sourceText = \"\" }) {\n    this.renderer = renderer;\n    this.audio = audio;\n    this.sourceProvider = asSourceProvider(sourceProvider, sourceText);\n    this.onGameOver = null;\n\n    this.currentSourceText = sourceText;\n    this.currentSourcePath = \"unknown.js\";\n    this.codeGrid = [];\n    this.styleGrid = [];\n    this.boardSize = { ...GRID };\n    this.remotePlayers = [];\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n    this.interval = null;\n  }\n\n  setOnGameOver(callback) {\n    this.onGameOver = callback;\n  }\n\n  setRemotePlayers(players) {\n    this.remotePlayers = (players || [])\n      .filter((player) => player && Array.isArray(player.snake))\n      .map((player) => ({\n        id: player.id,\n        name: player.name,\n        score: player.score,\n        snake: player.snake\n      }));\n    this.render();\n  }\n\n  reset() {\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n    this.boardSize = this.computeBoardSize();\n    this.rebuildBoard();\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n\n    this.pickNextTargets();\n    this.refreshHazards();\n    this.syncHud();\n    this.renderer.setMessage(UI_TEXT.ready);\n    this.render();\n  }\n\n  start() {\n    if (this.state.running) return;\n    if (this.state.gameOver) this.reset();\n\n    if (!this.audio.isEnabled()) {\n      void this.audio.ensureEnabledForGameplay();\n    }\n\n    this.state.running = true;\n    this.audio.setPlaybackActive(true);\n    this.audio.setGameSpeed(this.state.speed);\n    this.audio.playStartSfx();\n    this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n  }\n\n  setDirection(x, y) {\n    const tail = this.state.directionQueue.length > 0\n      ? this.state.directionQueue[this.state.directionQueue.length - 1]\n      : this.state.direction;\n\n    if (tail.x === -x && tail.y === -y) return;\n    if (tail.x === x && tail.y === y) return;\n\n    this.state.directionQueue.push({ x, y });\n    if (this.state.directionQueue.length > 2) this.state.directionQueue.shift();\n  }\n\n  toggleAudio() {\n    void this.audio.toggle();\n  }\n\n  dispose() {\n    this.stopLoop();\n    this.audio.dispose();\n  }\n\n  rebuildBoard() {\n    this.currentSourceText = this.sourceProvider.nextSource({\n      width: this.boardSize.width,\n      height: this.boardSize.height\n    });\n    this.currentSourcePath = this.extractSourcePath(this.currentSourceText);\n\n    this.codeGrid = buildCodeGrid(\n      this.currentSourceText,\n      this.boardSize.width,\n      this.boardSize.height\n    );\n    this.styleGrid = buildStyleGrid(this.codeGrid, KEYWORDS);\n  }\n\n  computeBoardSize() {\n    const measured = this.renderer.measureBoardSize?.();\n    if (\n      measured &&\n      Number.isInteger(measured.width) &&\n      Number.isInteger(measured.height) &&\n      measured.width > 0 &&\n      measured.height > 0\n    ) {\n      return measured;\n    }\n    return { ...GRID };\n  }\n\n  updateLoopSpeed() {\n    const delayMs = Math.max(SPEED.minDelayMs, Math.floor(SPEED.baseDelayMs / this.state.speed));\n    this.stopLoop();\n    this.interval = setInterval(() => this.tick(), delayMs);\n  }\n\n  stopLoop() {\n    if (!this.interval) return;\n    clearInterval(this.interval);\n    this.interval = null;\n  }\n\n  syncHud() {\n    this.renderer.updateStatus({\n      score: this.state.score,\n      stage: this.state.stage,\n      targetChar: this.currentTargetLabel(),\n      avoidChars: this.currentAvoidLabel(),\n      eaten: this.state.eatenCount,\n      speed: this.state.speed,\n      audioEnabled: this.audio.isEnabled()\n    });\n  }\n\n  render() {\n    this.renderer.renderBoard({\n      codeGrid: this.codeGrid,\n      styleGrid: this.styleGrid,\n      eaten: this.state.eaten,\n      corruptedChars: this.state.corruptedChars,\n      activeTargets: this.state.activeTargets,\n      hazardCells: this.state.hazardCells,\n      remotePlayers: this.remotePlayers,\n      snake: this.state.snake,\n      gameOver: this.state.gameOver,\n      won: this.state.won\n    });\n  }\n\n  tick() {\n    if (!this.state.running || this.state.gameOver) return;\n\n    const queued = this.state.directionQueue.shift();\n    if (queued) this.state.direction = queued;\n\n    const head = this.state.snake[0];\n    const next = {\n      x: head.x + this.state.direction.x,\n      y: head.y + this.state.direction.y\n    };\n\n    if (!inBounds(next.x, next.y, this.boardSize.width, this.boardSize.height)) {\n      this.endGame(false);\n      return;\n    }\n\n    if (this.collidesWithSnake(next.x, next.y)) {\n      this.endGame(false);\n      return;\n    }\n\n    if (this.collidesWithRemoteSnake(next.x, next.y)) {\n      this.endGame(false, false, false, true);\n      return;\n    }\n\n    const nextKey = cellKey(next.x, next.y);\n    if (this.state.eaten.has(nextKey)) {\n      this.endGame(false, false, true);\n      return;\n    }\n\n    if (this.state.hazardCells.has(nextKey)) {\n      this.endGame(false, true);\n      return;\n    }\n\n    this.state.snake.unshift(next);\n\n    let leveledUp = false;\n    if (this.state.activeTargets.has(nextKey)) {\n      leveledUp = this.eatTarget(nextKey);\n    } else if (this.state.growth > 0) {\n      this.state.growth -= 1;\n    } else {\n      this.state.snake.pop();\n    }\n\n    if (this.state.gameOver) {\n      this.syncHud();\n      this.render();\n      return;\n    }\n\n    this.refreshHazards();\n    this.syncHud();\n    if (!leveledUp) this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n    this.render();\n  }\n\n  collidesWithSnake(x, y) {\n    for (let i = 0; i < this.state.snake.length; i += 1) {\n      const segment = this.state.snake[i];\n      if (segment.x === x && segment.y === y) return true;\n    }\n    return false;\n  }\n\n  collidesWithRemoteSnake(x, y) {\n    for (const player of this.remotePlayers) {\n      for (let i = 0; i < player.snake.length; i += 1) {\n        const segment = player.snake[i];\n        if (segment.x === x && segment.y === y) return true;\n      }\n    }\n    return false;\n  }\n\n  eatTarget(cell) {\n    this.state.activeTargets.delete(cell);\n    this.state.eaten.add(cell);\n    this.state.corruptedChars.set(cell, this.randomCorruptionChar());\n    this.state.hazardCells.delete(cell);\n    this.state.eatenCount += 1;\n    this.state.eatenThisTarget += 1;\n    this.state.score += 12 + this.state.snake.length;\n    this.state.growth += 1;\n    this.state.speed = Math.min(\n      SPEED.maxMultiplier,\n      1 + this.state.eatenCount * SPEED.increasePerEat\n    );\n    this.audio.setGameSpeed(this.state.speed);\n\n    this.renderer.triggerGlitch();\n    this.audio.playEatSfx();\n\n    if (this.checkStageProgress()) return true;\n\n    if (this.state.eatenThisTarget >= this.state.targetQuota) {\n      this.pickNextTargets();\n      this.refreshHazards(true);\n      return false;\n    }\n\n    this.maybeRefreshTargets();\n    return false;\n  }\n\n  randomCorruptionChar() {\n    const idx = Math.floor(Math.random() * CORRUPTION_CHARS.length);\n    return CORRUPTION_CHARS[idx];\n  }\n\n  maybeRefreshTargets() {\n    if (this.state.activeTargets.size > 0) return;\n    this.pickNextTargets();\n  }\n\n  checkStageProgress() {\n    const nextStage = 1 + Math.floor(this.state.eatenCount / STAGES.corruptionsPerLevel);\n    if (nextStage <= this.state.stage) return false;\n\n    while (this.state.stage < nextStage && !this.state.gameOver) {\n      this.state.stage += 1;\n      this.advanceStage();\n    }\n\n    return true;\n  }\n\n  advanceStage() {\n    this.rebuildBoard();\n    this.state.activeTargets.clear();\n    this.state.hazardCells.clear();\n    this.state.activeHazardChars = [];\n    this.state.eatenThisTarget = 0;\n\n    const hasTargets = this.pickNextTargets();\n    if (!hasTargets) return;\n\n    this.refreshHazards(true);\n    this.renderer.triggerGlitch();\n    this.audio.playStartSfx();\n    this.renderer.setMessage(`Stage ${this.state.stage} breach. Injecting ${this.currentSourcePath}.`);\n  }\n\n  pickNextTargets() {\n    const charCount = Math.min(\n      TARGETS.maxChars,\n      TARGETS.minChars + Math.floor(this.state.eatenCount / TARGETS.charGrowthStep)\n    );\n\n    const selected = [];\n    for (let i = 0; i < TARGET_SEQUENCE.length && selected.length < charCount; i += 1) {\n      const idx = (this.state.currentTargetIndex + i) % TARGET_SEQUENCE.length;\n      const char = TARGET_SEQUENCE[idx];\n      const pool = collectTargetCandidates(this.codeGrid, char, this.state.eaten);\n      if (pool.length === 0) continue;\n      selected.push({ idx, char, pool });\n    }\n\n    if (selected.length === 0) {\n      this.state.won = true;\n      this.state.running = false;\n      this.state.gameOver = true;\n      this.stopLoop();\n      this.audio.setPlaybackActive(false);\n      this.renderer.setMessage(UI_TEXT.fullCorruptionReset);\n      return false;\n    }\n\n    const perCharCap = Math.min(\n      TARGETS.perCharMax,\n      TARGETS.perCharBase + Math.floor(this.state.score / TARGETS.perCharScoreStep)\n    );\n\n    const targetCells = new Set();\n    for (const item of selected) {\n      for (const cell of shuffled(item.pool).slice(0, perCharCap)) {\n        targetCells.add(cell);\n      }\n    }\n\n    this.state.activeTargetChars = selected.map((item) => item.char);\n    this.state.currentTargetIndex = (selected[selected.length - 1].idx + 1) % TARGET_SEQUENCE.length;\n    this.state.activeTargets = targetCells;\n    this.state.eatenThisTarget = 0;\n    this.state.targetQuota = Math.min(\n      TARGETS.maxQuota,\n      TARGETS.baseQuota + Math.floor(this.state.score / TARGETS.scoreStep)\n    );\n\n    return true;\n  }\n\n  desiredHazardCount() {\n    if (this.state.eatenCount < HAZARDS.unlockAtEaten) return 0;\n    const growth = Math.floor((this.state.eatenCount - HAZARDS.unlockAtEaten) / HAZARDS.growthStep);\n    return Math.min(HAZARDS.maxCount, HAZARDS.baseCount + growth * 3);\n  }\n\n  refreshHazards(forceReset = false) {\n    const desiredCount = this.desiredHazardCount();\n    if (desiredCount <= 0) {\n      this.state.hazardCells.clear();\n      this.state.activeHazardChars = [];\n      return;\n    }\n\n    if (forceReset) this.state.hazardCells.clear();\n\n    const snakeSet = new Set(this.state.snake.map((segment) => cellKey(segment.x, segment.y)));\n    const byChar = new Map();\n\n    for (const char of HAZARD_SEQUENCE) {\n      const candidates = collectTargetCandidates(this.codeGrid, char, this.state.eaten)\n        .filter((key) => !this.state.activeTargets.has(key))\n        .filter((key) => !snakeSet.has(key));\n\n      if (candidates.length > 0) byChar.set(char, shuffled(candidates));\n    }\n\n    this.state.activeHazardChars = [...byChar.keys()].slice(0, 4);\n\n    const validExisting = new Set();\n    for (const key of this.state.hazardCells) {\n      if (this.state.activeTargets.has(key) || this.state.eaten.has(key) || snakeSet.has(key)) continue;\n      const [x, y] = key.split(\",\").map(Number);\n      if (!inBounds(x, y, this.boardSize.width, this.boardSize.height)) continue;\n      validExisting.add(key);\n    }\n\n    this.state.hazardCells = validExisting;\n\n    const pools = [...byChar.values()];\n    let poolIndex = 0;\n    while (this.state.hazardCells.size < desiredCount && pools.length > 0) {\n      const pool = pools[poolIndex % pools.length];\n      const next = pool.pop();\n      if (next) this.state.hazardCells.add(next);\n      poolIndex += 1;\n\n      if (pool.length === 0) {\n        const idx = pools.indexOf(pool);\n        if (idx >= 0) pools.splice(idx, 1);\n      }\n    }\n  }\n\n  endGame(didWin, hitHazard = false, hitCorruption = false, hitPlayer = false) {\n    this.state.running = false;\n    this.state.gameOver = true;\n    this.state.won = didWin;\n    this.state.gameOverReason = didWin\n      ? \"win\"\n      : (hitPlayer ? \"player\" : (hitCorruption ? \"corruption\" : (hitHazard ? \"hazard\" : \"crash\")));\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n\n    if (!didWin) this.audio.playCrashSfx();\n\n    const message = didWin\n      ? UI_TEXT.fullCorruption\n      : (hitPlayer\n        ? UI_TEXT.playerCrash\n        : (hitCorruption\n        ? UI_TEXT.corruptionCrash\n        : (hitHazard ? UI_TEXT.hazardCrash : UI_TEXT.crash)));\n\n    this.renderer.setMessage(message);\n    this.render();\n    if (typeof this.onGameOver === \"function\") {\n      this.onGameOver(this.state.gameOverReason);\n    }\n  }\n\n  currentTargetLabel() {\n    if (this.state.activeTargetChars.length === 0) {\n      return TARGET_SEQUENCE[this.state.currentTargetIndex] || TARGET_SEQUENCE[0];\n    }\n\n    return this.state.activeTargetChars.join(\" \");\n  }\n\n  currentAvoidLabel() {\n    if (this.state.activeHazardChars.length === 0) return \"-\";\n    return this.state.activeHazardChars.join(\" \");\n  }\n\n  progressMessage() {\n    const target = this.currentTargetLabel();\n    const avoid = this.currentAvoidLabel();\n    return `Stage ${this.state.stage} | Corrupt [${target}] (${this.state.eatenThisTarget}/${this.state.targetQuota}). Avoid [${avoid}].`;\n  }\n\n  extractSourcePath(text) {\n    if (!text) return \"unknown.js\";\n    const firstLine = text.split(\"\\n\", 1)[0].trim();\n    if (!firstLine.startsWith(\"// source:\")) return \"unknown.js\";\n    const path = firstLine.slice(\"// source:\".length).trim();\n    return path || \"unknown.js\";\n  }\n}\n"
  },
  {
    "path": "src/game/game-state.js",
    "content": "import { START_DIRECTION } from \"./constants.js\";\n\nfunction createInitialSnake(width, height) {\n  const x = Math.floor(width / 2);\n  const y = Math.floor(height / 2);\n\n  return [\n    { x: x - 1, y },\n    { x: x - 2, y },\n    { x: x - 3, y }\n  ];\n}\n\nexport function createInitialState(width, height) {\n  return {\n    eaten: new Set(),\n    corruptedChars: new Map(),\n    snake: createInitialSnake(width, height),\n    direction: { ...START_DIRECTION },\n    queuedDirection: { ...START_DIRECTION },\n    directionQueue: [],\n    score: 0,\n    stage: 1,\n    eatenCount: 0,\n    currentTargetIndex: 0,\n    activeTargetChars: [],\n    targetQuota: 7,\n    eatenThisTarget: 0,\n    activeTargets: new Set(),\n    hazardCells: new Set(),\n    activeHazardChars: [],\n    growth: 0,\n    speed: 1,\n    running: false,\n    gameOver: false,\n    gameOverReason: null,\n    won: false\n  };\n}\n"
  },
  {
    "path": "src/game/grid.js",
    "content": "export function buildCodeGrid(sourceText, width, height) {\n  const lines = sourceText.split(\"\\n\").slice(0, height);\n  return Array.from({ length: height }, (_, y) => {\n    const base = (lines[y] || \"\").padEnd(width, \" \").slice(0, width);\n    return base.split(\"\");\n  });\n}\n\nexport function cellKey(x, y) {\n  return `${x},${y}`;\n}\n\nexport function inBounds(x, y, width, height) {\n  return x >= 0 && x < width && y >= 0 && y < height;\n}\n\nexport function shuffled(values) {\n  const copy = values.slice();\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n}\n\nexport function collectTargetCandidates(codeGrid, char, eatenSet) {\n  const candidates = [];\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const key = cellKey(x, y);\n      if (eatenSet.has(key)) continue;\n      if (codeGrid[y][x] === char) candidates.push(key);\n    }\n  }\n\n  return candidates;\n}\n"
  },
  {
    "path": "src/game/input-controller.js",
    "content": "export function bindInput({ onDirection, onStart, onToggleAudio }) {\n  const handler = (event) => {\n    const key = event.key.toLowerCase();\n\n    if (key === \"arrowup\" || key === \"w\") {\n      event.preventDefault();\n      onDirection(0, -1);\n    }\n\n    if (key === \"arrowdown\" || key === \"s\") {\n      event.preventDefault();\n      onDirection(0, 1);\n    }\n\n    if (key === \"arrowleft\" || key === \"a\") {\n      event.preventDefault();\n      onDirection(-1, 0);\n    }\n\n    if (key === \"arrowright\" || key === \"d\") {\n      event.preventDefault();\n      onDirection(1, 0);\n    }\n\n    if (key === \" \" || key === \"enter\") {\n      event.preventDefault();\n      onStart();\n    }\n\n    if (key === \"m\") {\n      event.preventDefault();\n      onToggleAudio();\n    }\n  };\n\n  document.addEventListener(\"keydown\", handler);\n\n  return () => {\n    document.removeEventListener(\"keydown\", handler);\n  };\n}\n"
  },
  {
    "path": "src/game/renderer.js",
    "content": "import { cellKey } from \"./grid.js\";\n\nfunction cellContent(char) {\n  if (char === \" \") return \"&nbsp;\";\n  if (char === \"<\") return \"&lt;\";\n  if (char === \">\") return \"&gt;\";\n  if (char === \"&\") return \"&amp;\";\n  return char;\n}\n\nexport class Renderer {\n  constructor(elements) {\n    this.elements = elements;\n  }\n\n  measureBoardSize() {\n    const editor = this.elements.editor;\n    if (!editor) return null;\n\n    const computed = getComputedStyle(editor);\n    const paddingX = Number.parseFloat(computed.paddingLeft) + Number.parseFloat(computed.paddingRight);\n    const paddingY = Number.parseFloat(computed.paddingTop) + Number.parseFloat(computed.paddingBottom);\n\n    const probe = document.createElement(\"span\");\n    probe.className = \"cell\";\n    probe.style.position = \"absolute\";\n    probe.style.visibility = \"hidden\";\n    probe.style.pointerEvents = \"none\";\n    probe.textContent = \"M\";\n    editor.appendChild(probe);\n    const charRect = probe.getBoundingClientRect();\n    editor.removeChild(probe);\n\n    const charWidth = Math.max(1, Math.ceil(charRect.width));\n    const lineHeight = Math.max(\n      1,\n      Math.ceil(Number.parseFloat(computed.lineHeight) || charRect.height)\n    );\n\n    const gutterWidth = 42;\n    const usableWidth = Math.max(0, editor.clientWidth - paddingX - gutterWidth);\n    const usableHeight = Math.max(0, editor.clientHeight - paddingY);\n    return {\n      width: Math.max(24, Math.floor(usableWidth / charWidth)),\n      height: Math.max(12, Math.floor(usableHeight / lineHeight))\n    };\n  }\n\n  updateStatus({ score, stage, targetChar, avoidChars, eaten, speed, audioEnabled }) {\n    this.elements.score.textContent = String(score);\n    this.elements.stage.textContent = String(stage);\n    this.elements.targetChar.textContent = targetChar;\n    this.elements.avoidChars.textContent = avoidChars;\n    this.elements.eaten.textContent = String(eaten);\n    this.elements.speed.textContent = `${speed.toFixed(1)}x`;\n    this.updateAudioStatus(audioEnabled);\n  }\n\n  updateAudioStatus(enabled) {\n    this.elements.audioStatus.textContent = enabled ? \"ON\" : \"OFF\";\n  }\n\n  setMessage(message) {\n    this.elements.message.textContent = message;\n  }\n\n  updatePlayers(players, localPlayerId = null) {\n    const list = this.elements.playersList;\n    if (!list) return;\n\n    if (!players || players.length === 0) {\n      list.innerHTML = '<li class=\"players-empty\">No players yet.</li>';\n      return;\n    }\n\n    const sorted = players\n      .slice()\n      .sort((a, b) => {\n        if ((b.score || 0) !== (a.score || 0)) return (b.score || 0) - (a.score || 0);\n        return (a.name || \"\").localeCompare(b.name || \"\");\n      });\n\n    list.innerHTML = sorted\n      .map((player) => {\n        const safeName = this.escapeHtml(player.name || \"anonymous\");\n        const label = player.id === localPlayerId ? `${safeName} (you)` : safeName;\n        const className = player.id === localPlayerId ? \"local-player\" : \"\";\n        const score = Number(player.score) || 0;\n        return `<li class=\"${className}\"><span>${label}</span><span>${score}</span></li>`;\n      })\n      .join(\"\");\n  }\n\n  triggerGlitch() {\n    this.elements.app.classList.remove(\"glitch\");\n    void this.elements.app.offsetWidth;\n    this.elements.app.classList.add(\"glitch\");\n    setTimeout(() => this.elements.app.classList.remove(\"glitch\"), 130);\n  }\n\n  renderBoard({\n    codeGrid,\n    styleGrid,\n    eaten,\n    corruptedChars,\n    activeTargets,\n    hazardCells,\n    remotePlayers = [],\n    snake,\n    gameOver,\n    won\n  }) {\n    const snakeSet = new Set(snake.map((segment) => cellKey(segment.x, segment.y)));\n    const remoteSnakeSet = new Set();\n    const remoteHeadSet = new Set();\n\n    for (const player of remotePlayers) {\n      if (!player || !Array.isArray(player.snake)) continue;\n      for (let i = 0; i < player.snake.length; i += 1) {\n        const segment = player.snake[i];\n        const key = cellKey(segment.x, segment.y);\n        remoteSnakeSet.add(key);\n        if (i === 0) remoteHeadSet.add(key);\n      }\n    }\n\n    const headKey = snake[0] ? cellKey(snake[0].x, snake[0].y) : \"\";\n\n    const html = [];\n    for (let y = 0; y < codeGrid.length; y += 1) {\n      html.push(`<span class=\"line\"><span class=\"ln\">${String(y + 1).padStart(2, \"0\")}</span>`);\n\n      for (let x = 0; x < codeGrid[y].length; x += 1) {\n        const key = cellKey(x, y);\n        let char = codeGrid[y][x];\n        let className = `cell ${styleGrid[y][x]}`;\n\n        if (eaten.has(key)) {\n          char = corruptedChars.get(key) || \"#\";\n          className += \" corrupted\";\n        } else if (hazardCells.has(key)) {\n          className += \" hazard\";\n        } else if (activeTargets.has(key)) {\n          className += \" target\";\n        }\n\n        if (snakeSet.has(key)) className += \" virus\";\n        if (!snakeSet.has(key) && remoteSnakeSet.has(key)) className += \" other-virus\";\n        if (!snakeSet.has(key) && remoteHeadSet.has(key)) className += \" other-head\";\n        if (key === headKey) className += \" head\";\n        if (gameOver && !won && key === headKey) className += \" dead\";\n\n        html.push(`<span class=\"${className}\">${cellContent(char)}</span>`);\n      }\n\n      html.push(\"</span>\");\n    }\n\n    this.elements.editor.innerHTML = html.join(\"\");\n  }\n\n  escapeHtml(text) {\n    return text\n      .replaceAll(\"&\", \"&amp;\")\n      .replaceAll(\"<\", \"&lt;\")\n      .replaceAll(\">\", \"&gt;\");\n  }\n}\n"
  },
  {
    "path": "src/game/source-text.js",
    "content": "import { HAZARD_SEQUENCE, TARGET_SEQUENCE } from \"./constants.js\";\nimport { SOURCE_CORPUS } from \"./source-corpus.js\";\n\nconst INTEREST_CHARS = new Set([...TARGET_SEQUENCE, ...HAZARD_SEQUENCE]);\n\nfunction scoreContent(content) {\n  let score = 0;\n  for (let i = 0; i < content.length; i += 1) {\n    if (INTEREST_CHARS.has(content[i])) score += 1;\n  }\n  return score;\n}\n\nfunction normalizeCorpus(corpus) {\n  return corpus\n    .map((entry) => {\n      const lines = entry.content.split(\"\\n\");\n      return {\n        path: entry.path,\n        lines,\n        interestScore: scoreContent(entry.content)\n      };\n    })\n    .filter((entry) => entry.lines.length > 0);\n}\n\nexport class SourceTextProvider {\n  constructor(corpus = SOURCE_CORPUS) {\n    this.entries = normalizeCorpus(corpus);\n    this.lastPick = null;\n  }\n\n  nextSource({ width, height }) {\n    if (this.entries.length === 0) return \"\";\n\n    const viable = this.entries.filter((entry) => entry.interestScore >= 18);\n    const pool = viable.length > 0 ? viable : this.entries;\n    let index = Math.floor(Math.random() * pool.length);\n\n    if (pool.length > 1 && this.lastPick && pool[index].path === this.lastPick.path) {\n      index = (index + 1 + Math.floor(Math.random() * (pool.length - 1))) % pool.length;\n    }\n\n    const entry = pool[index];\n    const bodyLines = Math.max(1, height - 2);\n    const maxStart = Math.max(0, entry.lines.length - bodyLines);\n    let start = maxStart > 0 ? Math.floor(Math.random() * (maxStart + 1)) : 0;\n\n    if (\n      maxStart > 0 &&\n      this.lastPick &&\n      this.lastPick.path === entry.path &&\n      this.lastPick.start === start\n    ) {\n      start = (start + 1 + Math.floor(Math.random() * maxStart)) % (maxStart + 1);\n    }\n\n    const end = start + bodyLines;\n    const selected = entry.lines.slice(start, end);\n    const header = [\n      `// source: ${entry.path}`,\n      `// region: ${start + 1}-${Math.min(entry.lines.length, end)}`\n    ];\n\n    const clipped = selected.map((line) => line.slice(0, Math.max(8, width)));\n    this.lastPick = { path: entry.path, start };\n    return [...header, ...clipped].join(\"\\n\");\n  }\n}\n\n"
  },
  {
    "path": "src/game/syntax-highlighter.js",
    "content": "function paintRange(styles, start, end, className) {\n  for (let i = start; i < end && i < styles.length; i += 1) styles[i] = className;\n}\n\nexport function buildStyleGrid(codeGrid, keywords) {\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n  const styleGrid = Array.from({ length: height }, () =>\n    Array.from({ length: width }, () => \"ch\")\n  );\n\n  for (let y = 0; y < height; y += 1) {\n    const line = codeGrid[y].join(\"\");\n    const styles = styleGrid[y];\n    let i = 0;\n\n    while (i < width) {\n      const ch = line[i];\n      const next = i + 1 < width ? line[i + 1] : \"\";\n\n      if (ch === \"/\" && next === \"/\") {\n        paintRange(styles, i, width, \"tk-comment\");\n        break;\n      }\n\n      if (ch === \"'\" || ch === '\"' || ch === \"`\") {\n        const quote = ch;\n        let j = i + 1;\n\n        while (j < width) {\n          if (line[j] === \"\\\\\" && j + 1 < width) {\n            j += 2;\n            continue;\n          }\n          if (line[j] === quote) {\n            j += 1;\n            break;\n          }\n          j += 1;\n        }\n\n        paintRange(styles, i, j, \"tk-string\");\n        i = j;\n        continue;\n      }\n\n      if (/[0-9]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[0-9_.]/.test(line[j])) j += 1;\n        paintRange(styles, i, j, \"tk-number\");\n        i = j;\n        continue;\n      }\n\n      if (/[A-Za-z_$]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[A-Za-z0-9_$]/.test(line[j])) j += 1;\n\n        const word = line.slice(i, j);\n        if (keywords.has(word)) {\n          paintRange(styles, i, j, \"tk-keyword\");\n        } else {\n          let lookahead = j;\n          while (lookahead < width && /\\s/.test(line[lookahead])) lookahead += 1;\n          if (lookahead < width && line[lookahead] === \"(\") {\n            paintRange(styles, i, j, \"tk-function\");\n          }\n        }\n\n        i = j;\n        continue;\n      }\n\n      if (\"{}[]();,.<>:+-*/=%!?&|\".includes(ch)) styles[i] = \"tk-punct\";\n      i += 1;\n    }\n  }\n\n  return styleGrid;\n}\n"
  },
  {
    "path": "src/main.js",
    "content": "import { AudioEngine } from \"./game/audio-engine.js\";\nimport { GameEngine } from \"./game/game-engine.js\";\nimport { bindInput } from \"./game/input-controller.js\";\nimport { Renderer } from \"./game/renderer.js\";\nimport { SourceTextProvider } from \"./game/source-text.js\";\nimport { formatMultiplayerJoinError } from \"./network/error-messages.js\";\nimport { createFirebaseBackend } from \"./network/firebase-backend.js\";\nimport { MultiplayerSession } from \"./network/multiplayer-session.js\";\n\nfunction requireElement(id) {\n  const element = document.getElementById(id);\n  if (!element) throw new Error(`Missing required element: #${id}`);\n  return element;\n}\n\nconst elements = {\n  app: requireElement(\"app\"),\n  editor: requireElement(\"editor\"),\n  score: requireElement(\"score\"),\n  stage: requireElement(\"stage\"),\n  targetChar: requireElement(\"targetChar\"),\n  avoidChars: requireElement(\"avoidChars\"),\n  eaten: requireElement(\"eaten\"),\n  speed: requireElement(\"speed\"),\n  audioStatus: requireElement(\"audioStatus\"),\n  message: requireElement(\"message\"),\n  playersList: requireElement(\"playersList\")\n};\n\nconst renderer = new Renderer(elements);\nconst audio = new AudioEngine((enabled) => renderer.updateAudioStatus(enabled));\nconst sourceProvider = new SourceTextProvider();\nconst game = new GameEngine({ renderer, audio, sourceProvider });\nconst introOverlay = requireElement(\"introOverlay\");\nconst introStart = requireElement(\"introStart\");\nconst playerNameInput = requireElement(\"playerName\");\nconst introError = requireElement(\"introError\");\nconst firebaseBackend = createFirebaseBackend();\nconst multiplayer = new MultiplayerSession({\n  backend: firebaseBackend,\n  onPlayersChanged: (players, localPlayerId) => {\n    renderer.updatePlayers(players, localPlayerId);\n    game.setRemotePlayers(multiplayer.getRemoteSnakePlayers());\n  },\n  onError: () => {\n    renderer.setMessage(\"Multiplayer sync error. Try restarting the run.\");\n  }\n});\n\nlet introVisible = true;\nlet joinInFlight = null;\n\nfunction setIntroBusy(isBusy) {\n  introStart.disabled = isBusy;\n  introStart.textContent = isBusy\n    ? \"Connecting to Multiplayer...\"\n    : \"Press Space or Click to Unleash\";\n}\n\nfunction dismissIntro() {\n  if (!introVisible) return;\n  introVisible = false;\n  introOverlay.classList.add(\"hidden\");\n}\n\nfunction setIntroError(message) {\n  introError.textContent = message || \"\";\n}\n\nasync function ensureRoomJoin() {\n  if (multiplayer.isJoined()) return true;\n  if (joinInFlight) return joinInFlight;\n\n  const name = playerNameInput.value.trim();\n  if (!name) {\n    setIntroError(\"Enter your operator name to begin.\");\n    playerNameInput.focus();\n    return false;\n  }\n\n  setIntroBusy(true);\n  setIntroError(\"Connecting to multiplayer...\");\n\n  joinInFlight = (async () => {\n    try {\n      await multiplayer.join(name);\n      setIntroError(\"\");\n      return true;\n    } catch (error) {\n      console.error(\"Multiplayer join failed:\", error);\n      setIntroError(formatMultiplayerJoinError(error));\n      playerNameInput.focus();\n      return false;\n    } finally {\n      setIntroBusy(false);\n      joinInFlight = null;\n    }\n  })();\n\n  return joinInFlight;\n}\n\nasync function startRun() {\n  const joined = await ensureRoomJoin();\n  if (!joined) return;\n  dismissIntro();\n  game.start();\n  multiplayer.pushState(game.state);\n}\n\nconst unbindInput = bindInput({\n  onDirection: (x, y) => game.setDirection(x, y),\n  onStart: () => void startRun(),\n  onToggleAudio: () => game.toggleAudio()\n});\n\nintroStart.addEventListener(\"click\", () => void startRun());\nplayerNameInput.addEventListener(\"keydown\", (event) => {\n  if (event.key === \"Enter\") {\n    event.preventDefault();\n    void startRun();\n  }\n});\n\nconst syncTimer = setInterval(() => {\n  multiplayer.pushState(game.state);\n}, 120);\n\ngame.setOnGameOver((reason) => {\n  multiplayer.pushState(game.state);\n  if (reason === \"player\") {\n    void multiplayer.leave(\"player-collision\");\n    game.setRemotePlayers([]);\n  }\n});\n\ngame.reset();\nrenderer.updatePlayers([], null);\nsetIntroBusy(false);\nplayerNameInput.focus();\n\nwindow.addEventListener(\"beforeunload\", () => {\n  clearInterval(syncTimer);\n  void multiplayer.leave(\"disconnect\");\n  unbindInput();\n  game.dispose();\n});\n"
  },
  {
    "path": "src/network/error-messages.js",
    "content": "function getErrorCode(error) {\n  return String(error?.code || \"\");\n}\n\nfunction includesIgnoreCase(text, pattern) {\n  return text.toLowerCase().includes(pattern.toLowerCase());\n}\n\nexport function formatMultiplayerJoinError(error) {\n  const code = getErrorCode(error);\n  const message = String(error?.message || \"\");\n\n  if (code === \"config/invalid\") {\n    return \"Firebase config is invalid or incomplete. Recheck apiKey/authDomain/projectId and related fields.\";\n  }\n\n  if (code === \"sdk/load-failed\") {\n    return \"Could not load Firebase SDK from gstatic. Check network/firewall or ad-block settings.\";\n  }\n\n  if (code === \"room/join-failed\") {\n    return \"Room allocation failed after retries. Try again in a moment.\";\n  }\n\n  if (code === \"permission-denied\") {\n    return \"Firestore denied access. Enable test rules or allow authenticated users in rules.\";\n  }\n\n  if (code === \"failed-precondition\") {\n    return \"Firestore not ready. Create a Firestore database in your Firebase project.\";\n  }\n\n  if (code === \"unavailable\") {\n    return \"Firebase unreachable. Check your network and try again.\";\n  }\n\n  if (\n    code === \"auth/operation-not-allowed\" ||\n    code === \"auth/configuration-not-found\" ||\n    code === \"auth/admin-restricted-operation\"\n  ) {\n    return \"Anonymous auth is disabled. Enable it in Firebase Auth or loosen Firestore rules.\";\n  }\n\n  if (code === \"auth/app-not-authorized\" || code === \"auth/unauthorized-domain\") {\n    return \"This host is not authorized for Firebase Auth. Add localhost to Authorized domains.\";\n  }\n\n  if (code === \"auth/invalid-api-key\") {\n    return \"Invalid Firebase API key. Verify the config values for this web app.\";\n  }\n\n  if (code === \"auth/network-request-failed\") {\n    return \"Auth request failed over network. Check connectivity/firewall and retry.\";\n  }\n\n  if (includesIgnoreCase(code, \"api-key\")) {\n    return \"Firebase API key is rejected. Check key value and API key restrictions.\";\n  }\n\n  if (includesIgnoreCase(message, \"API has not been used\") || includesIgnoreCase(message, \"not been used\")) {\n    return \"Firestore API is disabled for this project. Enable it in Google Cloud/Firebase console.\";\n  }\n\n  if (includesIgnoreCase(message, \"Failed to fetch dynamically imported module\")) {\n    return \"Could not download Firebase SDK modules. Check network/firewall or ad-block settings.\";\n  }\n\n  if (code) {\n    return `Failed to connect to multiplayer (${code}). Check Firebase config/network.`;\n  }\n\n  return \"Failed to connect to multiplayer. Check Firebase config/network.\";\n}\n"
  },
  {
    "path": "src/network/firebase-backend.js",
    "content": "import { chooseRoomForJoin } from \"./room-logic.js\";\n\nexport const FIREBASE_DEMO_CONFIG = Object.freeze({\n  apiKey: \"AIzaSyD5aaYlEOdziFWWMQxQkmVj3Pn7POD2ASg\",\n  authDomain: \"snake-virus.firebaseapp.com\",\n  projectId: \"snake-virus\",\n  storageBucket: \"snake-virus.firebasestorage.app\",\n  messagingSenderId: \"575294686498\",\n  appId: \"1:575294686498:web:0bd6274a409a39db4fd17b\",\n  measurementId: \"G-DYR95Y4K6V\"\n});\n\nconst ROOMS_COLLECTION = \"snake_virus_rooms\";\nconst PLAYERS_SUBCOLLECTION = \"players\";\nconst JOIN_RETRY_ATTEMPTS = 6;\nconst REQUIRED_CONFIG_KEYS = Object.freeze([\n  \"apiKey\",\n  \"authDomain\",\n  \"projectId\",\n  \"storageBucket\",\n  \"messagingSenderId\",\n  \"appId\"\n]);\n\nlet sdkCache = null;\n\nfunction createCodedError(code, message, cause = null) {\n  const error = new Error(message);\n  error.code = code;\n  if (cause) error.cause = cause;\n  return error;\n}\n\nfunction resolveRuntimeConfig(config = null) {\n  if (config) return config;\n  const runtimeConfig =\n    globalThis.__SNAKE_VIRUS_FIREBASE_CONFIG__ || globalThis.SNAKE_VIRUS_FIREBASE_CONFIG__;\n  return runtimeConfig || FIREBASE_DEMO_CONFIG;\n}\n\nfunction validateFirebaseConfig(config) {\n  if (!config || typeof config !== \"object\") {\n    throw createCodedError(\"config/invalid\", \"Firebase config is missing or not an object.\");\n  }\n\n  const missingKeys = REQUIRED_CONFIG_KEYS.filter((key) => {\n    return typeof config[key] !== \"string\" || config[key].trim() === \"\";\n  });\n\n  if (missingKeys.length > 0) {\n    throw createCodedError(\n      \"config/invalid\",\n      `Firebase config is missing required keys: ${missingKeys.join(\", \")}.`\n    );\n  }\n}\n\nfunction isDemoConfig(config) {\n  if (!config) return false;\n  return (\n    config.projectId === FIREBASE_DEMO_CONFIG.projectId &&\n    config.apiKey === FIREBASE_DEMO_CONFIG.apiKey\n  );\n}\n\nfunction createPlayerId() {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === \"function\") {\n    return globalThis.crypto.randomUUID();\n  }\n  return `p_${Date.now()}_${Math.floor(Math.random() * 1_000_000)}`;\n}\n\nasync function loadFirebaseSdk() {\n  if (sdkCache) return sdkCache;\n\n  let appModule;\n  let firestoreModule;\n  let authModule;\n  try {\n    [appModule, firestoreModule, authModule] = await Promise.all([\n      import(\"https://www.gstatic.com/firebasejs/10.14.1/firebase-app.js\"),\n      import(\"https://www.gstatic.com/firebasejs/10.14.1/firebase-firestore.js\"),\n      import(\"https://www.gstatic.com/firebasejs/10.14.1/firebase-auth.js\")\n    ]);\n  } catch (error) {\n    throw createCodedError(\n      \"sdk/load-failed\",\n      \"Unable to load Firebase SDK modules from gstatic.\",\n      error\n    );\n  }\n\n  sdkCache = {\n    initializeApp: appModule.initializeApp,\n    getApps: appModule.getApps,\n    getApp: appModule.getApp,\n    getFirestore: firestoreModule.getFirestore,\n    collection: firestoreModule.collection,\n    doc: firestoreModule.doc,\n    getDocs: firestoreModule.getDocs,\n    runTransaction: firestoreModule.runTransaction,\n    query: firestoreModule.query,\n    orderBy: firestoreModule.orderBy,\n    limit: firestoreModule.limit,\n    onSnapshot: firestoreModule.onSnapshot,\n    setDoc: firestoreModule.setDoc,\n    serverTimestamp: firestoreModule.serverTimestamp,\n    increment: firestoreModule.increment,\n    getAuth: authModule.getAuth,\n    signInAnonymously: authModule.signInAnonymously\n  };\n\n  return sdkCache;\n}\n\nexport class FirebaseBackend {\n  constructor(config = null) {\n    this.config = resolveRuntimeConfig(config);\n    this.app = null;\n    this.db = null;\n    this.auth = null;\n    this.sdk = null;\n  }\n\n  async ensureReady() {\n    if (this.db) return;\n    validateFirebaseConfig(this.config);\n    if (isDemoConfig(this.config)) {\n      console.warn(\n        \"[Snake Virus] Using bundled demo Firebase config. Override with your project config before multiplayer testing.\"\n      );\n    }\n    this.sdk = await loadFirebaseSdk();\n    const {\n      initializeApp,\n      getApps,\n      getApp,\n      getFirestore,\n      getAuth,\n      signInAnonymously\n    } = this.sdk;\n\n    try {\n      this.app = getApps().length > 0 ? getApp() : initializeApp(this.config);\n      this.db = getFirestore(this.app);\n      this.auth = getAuth(this.app);\n    } catch (error) {\n      throw createCodedError(\n        \"config/invalid\",\n        \"Firebase failed to initialize. Verify your project config values.\",\n        error\n      );\n    }\n\n    if (!this.auth.currentUser) {\n      try {\n        await signInAnonymously(this.auth);\n      } catch (error) {\n        const code = error?.code || \"\";\n        const isNonBlockingAuthConfigError =\n          code === \"auth/operation-not-allowed\" ||\n          code === \"auth/admin-restricted-operation\" ||\n          code === \"auth/configuration-not-found\";\n\n        if (!isNonBlockingAuthConfigError) throw error;\n      }\n    }\n  }\n\n  async joinRoom({ name, maxPlayers }) {\n    await this.ensureReady();\n\n    const {\n      collection,\n      doc,\n      getDocs,\n      runTransaction,\n      query,\n      orderBy,\n      limit,\n      serverTimestamp\n    } = this.sdk;\n\n    const roomsRef = collection(this.db, ROOMS_COLLECTION);\n    const playerId = createPlayerId();\n    const roomQuery = query(roomsRef, orderBy(\"activeCount\", \"asc\"), limit(25));\n\n    for (let attempt = 0; attempt < JOIN_RETRY_ATTEMPTS; attempt += 1) {\n      const snapshot = await getDocs(roomQuery);\n      const rooms = snapshot.docs.map((item) => ({ id: item.id, ...item.data(), ref: item.ref }));\n      const chosen = chooseRoomForJoin(rooms, maxPlayers);\n      const roomRef = chosen ? chosen.ref : doc(roomsRef);\n      const isNewRoom = !chosen;\n\n      try {\n        const roomId = await runTransaction(this.db, async (tx) => {\n          if (isNewRoom) {\n            tx.set(roomRef, {\n              activeCount: 1,\n              createdAt: serverTimestamp(),\n              updatedAt: serverTimestamp()\n            });\n          } else {\n            const roomSnap = await tx.get(roomRef);\n            const roomData = roomSnap.exists() ? roomSnap.data() : {};\n            const activeCount = Math.max(0, Number(roomData.activeCount) || 0);\n\n            if (activeCount >= maxPlayers) {\n              throw createCodedError(\"room/full-retry\", \"Room reached max players during join.\");\n            }\n\n            tx.set(\n              roomRef,\n              {\n                activeCount: activeCount + 1,\n                updatedAt: serverTimestamp()\n              },\n              { merge: true }\n            );\n          }\n\n          const playerRef = doc(roomRef, PLAYERS_SUBCOLLECTION, playerId);\n          tx.set(playerRef, {\n            id: playerId,\n            name,\n            score: 0,\n            stage: 1,\n            snake: [],\n            gameOver: false,\n            gameOverReason: null,\n            running: false,\n            status: \"active\",\n            joinedAt: serverTimestamp(),\n            updatedAt: serverTimestamp()\n          });\n\n          return roomRef.id;\n        });\n\n        return { roomId, playerId };\n      } catch (error) {\n        if (error?.code === \"room/full-retry\" && attempt < JOIN_RETRY_ATTEMPTS - 1) {\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    throw createCodedError(\"room/join-failed\", \"Unable to assign player to a room.\");\n  }\n\n  subscribeToRoomPlayers(roomId, onPlayersChanged) {\n    const { collection, onSnapshot } = this.sdk;\n    const playersRef = collection(this.db, ROOMS_COLLECTION, roomId, PLAYERS_SUBCOLLECTION);\n\n    return onSnapshot(playersRef, (snapshot) => {\n      const players = snapshot.docs.map((item) => ({ id: item.id, ...item.data() }));\n      onPlayersChanged(players);\n    });\n  }\n\n  async updatePlayerState({ roomId, playerId, payload }) {\n    await this.ensureReady();\n    const { doc, setDoc, serverTimestamp } = this.sdk;\n\n    const playerRef = doc(this.db, ROOMS_COLLECTION, roomId, PLAYERS_SUBCOLLECTION, playerId);\n    await setDoc(\n      playerRef,\n      {\n        ...payload,\n        status: \"active\",\n        updatedAt: serverTimestamp()\n      },\n      { merge: true }\n    );\n  }\n\n  async leaveRoom({ roomId, playerId, reason = \"left\" }) {\n    await this.ensureReady();\n    const { doc, runTransaction, serverTimestamp } = this.sdk;\n\n    const roomRef = doc(this.db, ROOMS_COLLECTION, roomId);\n    const playerRef = doc(this.db, ROOMS_COLLECTION, roomId, PLAYERS_SUBCOLLECTION, playerId);\n\n    await runTransaction(this.db, async (tx) => {\n      const roomSnap = await tx.get(roomRef);\n      const playerSnap = await tx.get(playerRef);\n      const roomData = roomSnap.exists() ? roomSnap.data() : {};\n      const playerData = playerSnap.exists() ? playerSnap.data() : null;\n\n      if (playerData && playerData.status !== \"left\") {\n        const nextCount = Math.max(0, Number(roomData.activeCount || 1) - 1);\n        tx.set(\n          roomRef,\n          {\n            activeCount: nextCount,\n            updatedAt: serverTimestamp()\n          },\n          { merge: true }\n        );\n      }\n\n      tx.set(\n        playerRef,\n        {\n          status: \"left\",\n          gameOver: true,\n          gameOverReason: reason,\n          running: false,\n          snake: [],\n          updatedAt: serverTimestamp()\n        },\n        { merge: true }\n      );\n    });\n  }\n}\n\nexport function createFirebaseBackend(config = null) {\n  return new FirebaseBackend(config);\n}\n"
  },
  {
    "path": "src/network/multiplayer-session.js",
    "content": "import {\n  MAX_PLAYERS_PER_ROOM,\n  getRemoteSnakePlayers,\n  normalizePlayerName,\n  normalizeRoomPlayers\n} from \"./room-logic.js\";\n\nfunction stateSignature(payload) {\n  return JSON.stringify(payload);\n}\n\nexport class MultiplayerSession {\n  constructor({\n    backend,\n    maxPlayers = MAX_PLAYERS_PER_ROOM,\n    onPlayersChanged = () => {},\n    onRoomChanged = () => {},\n    onError = () => {}\n  }) {\n    this.backend = backend;\n    this.maxPlayers = maxPlayers;\n    this.onPlayersChanged = onPlayersChanged;\n    this.onRoomChanged = onRoomChanged;\n    this.onError = onError;\n\n    this.roomId = null;\n    this.playerId = null;\n    this.playerName = \"\";\n    this.players = [];\n    this.unsubscribePlayers = null;\n    this.lastStateSig = \"\";\n  }\n\n  isJoined() {\n    return Boolean(this.roomId && this.playerId);\n  }\n\n  getRoomId() {\n    return this.roomId;\n  }\n\n  getPlayerId() {\n    return this.playerId;\n  }\n\n  getPlayers() {\n    return this.players.slice();\n  }\n\n  getRemoteSnakePlayers() {\n    return getRemoteSnakePlayers(this.players, this.playerId);\n  }\n\n  async join(rawName) {\n    const name = normalizePlayerName(rawName);\n    if (!name) throw new Error(\"Player name is required.\");\n    if (!this.backend) throw new Error(\"Multiplayer backend is not configured.\");\n    if (this.isJoined()) return { roomId: this.roomId, playerId: this.playerId };\n\n    const joined = await this.backend.joinRoom({\n      name,\n      maxPlayers: this.maxPlayers\n    });\n\n    this.roomId = joined.roomId;\n    this.playerId = joined.playerId;\n    this.playerName = name;\n    this.lastStateSig = \"\";\n\n    this.unsubscribePlayers = this.backend.subscribeToRoomPlayers(this.roomId, (players) => {\n      this.players = normalizeRoomPlayers(players);\n      this.onPlayersChanged(this.players, this.playerId, this.roomId);\n    });\n\n    this.onRoomChanged(this.roomId);\n    return { roomId: this.roomId, playerId: this.playerId };\n  }\n\n  async leave(reason = \"left\") {\n    if (!this.isJoined()) return;\n\n    const roomId = this.roomId;\n    const playerId = this.playerId;\n\n    if (typeof this.unsubscribePlayers === \"function\") {\n      this.unsubscribePlayers();\n      this.unsubscribePlayers = null;\n    }\n\n    this.roomId = null;\n    this.playerId = null;\n    this.players = [];\n    this.lastStateSig = \"\";\n    this.onPlayersChanged([], null, null);\n    this.onRoomChanged(null);\n\n    try {\n      await this.backend.leaveRoom({ roomId, playerId, reason });\n    } catch (error) {\n      this.onError(error);\n    }\n  }\n\n  pushState(state) {\n    if (!this.isJoined()) return;\n\n    const running = Boolean(state.running) && !state.gameOver;\n    const payload = {\n      name: this.playerName,\n      score: Number(state.score) || 0,\n      stage: Number(state.stage) || 1,\n      gameOver: Boolean(state.gameOver),\n      gameOverReason: state.gameOverReason || null,\n      running,\n      snake: running && Array.isArray(state.snake) ? state.snake : []\n    };\n\n    const sig = stateSignature(payload);\n    if (sig === this.lastStateSig) return;\n    this.lastStateSig = sig;\n\n    this.backend\n      .updatePlayerState({\n        roomId: this.roomId,\n        playerId: this.playerId,\n        payload\n      })\n      .catch((error) => this.onError(error));\n  }\n}\n"
  },
  {
    "path": "src/network/room-logic.js",
    "content": "export const MAX_PLAYERS_PER_ROOM = 5;\n\nexport function normalizePlayerName(input) {\n  const cleaned = String(input || \"\").trim().replace(/\\s+/g, \" \");\n  if (!cleaned) return \"\";\n  return cleaned.slice(0, 20);\n}\n\nfunction normalizeTimestamp(value) {\n  if (!value) return 0;\n  if (typeof value === \"number\") return value;\n  if (typeof value.toMillis === \"function\") return value.toMillis();\n  return 0;\n}\n\nexport function chooseRoomForJoin(rooms, maxPlayers = MAX_PLAYERS_PER_ROOM) {\n  const eligible = rooms\n    .filter((room) => Number(room.activeCount) < maxPlayers)\n    .sort((a, b) => {\n      const countDelta = Number(a.activeCount) - Number(b.activeCount);\n      if (countDelta !== 0) return countDelta;\n      return normalizeTimestamp(a.updatedAt) - normalizeTimestamp(b.updatedAt);\n    });\n\n  return eligible[0] || null;\n}\n\nexport function normalizeRoomPlayers(players) {\n  return players\n    .filter((player) => player && player.status !== \"left\")\n    .map((player) => ({\n      id: player.id,\n      name: normalizePlayerName(player.name) || \"anonymous\",\n      score: Number(player.score) || 0,\n      stage: Number(player.stage) || 1,\n      gameOver: Boolean(player.gameOver),\n      snake: Array.isArray(player.snake) ? player.snake : []\n    }));\n}\n\nexport function getRemoteSnakePlayers(players, localPlayerId) {\n  return normalizeRoomPlayers(players)\n    .filter((player) => player.id !== localPlayerId)\n    .filter((player) => !player.gameOver)\n    .filter((player) => player.snake.length > 0);\n}\n"
  },
  {
    "path": "tests/error-messages.test.js",
    "content": "import { formatMultiplayerJoinError } from \"../src/network/error-messages.js\";\n\ndescribe(\"formatMultiplayerJoinError\", () => {\n  test(\"maps invalid config error\", () => {\n    const text = formatMultiplayerJoinError({ code: \"config/invalid\" });\n    expect(text).toMatch(/config is invalid or incomplete/i);\n  });\n\n  test(\"maps SDK load failures\", () => {\n    const text = formatMultiplayerJoinError({ code: \"sdk/load-failed\" });\n    expect(text).toMatch(/Could not load Firebase SDK/i);\n  });\n\n  test(\"maps room join retry exhaustion\", () => {\n    const text = formatMultiplayerJoinError({ code: \"room/join-failed\" });\n    expect(text).toMatch(/Room allocation failed/i);\n  });\n\n  test(\"maps permission denied to firestore rules guidance\", () => {\n    const text = formatMultiplayerJoinError({ code: \"permission-denied\" });\n    expect(text).toMatch(/Firestore denied access/i);\n  });\n\n  test(\"maps failed precondition to firestore creation guidance\", () => {\n    const text = formatMultiplayerJoinError({ code: \"failed-precondition\" });\n    expect(text).toMatch(/Create a Firestore database/i);\n  });\n\n  test(\"maps anonymous auth configuration errors\", () => {\n    const text = formatMultiplayerJoinError({ code: \"auth/operation-not-allowed\" });\n    expect(text).toMatch(/Anonymous auth is disabled/i);\n  });\n\n  test(\"maps invalid API key auth errors\", () => {\n    const text = formatMultiplayerJoinError({ code: \"auth/invalid-api-key\" });\n    expect(text).toMatch(/Invalid Firebase API key/i);\n  });\n\n  test(\"maps unauthorized domain auth errors\", () => {\n    const text = formatMultiplayerJoinError({ code: \"auth/unauthorized-domain\" });\n    expect(text).toMatch(/Authorized domains/i);\n  });\n\n  test(\"maps app not authorized auth errors\", () => {\n    const text = formatMultiplayerJoinError({ code: \"auth/app-not-authorized\" });\n    expect(text).toMatch(/Authorized domains/i);\n  });\n\n  test(\"maps auth network request failures\", () => {\n    const text = formatMultiplayerJoinError({ code: \"auth/network-request-failed\" });\n    expect(text).toMatch(/network/i);\n  });\n\n  test(\"maps dynamic import fetch failures by message\", () => {\n    const text = formatMultiplayerJoinError({\n      message: \"TypeError: Failed to fetch dynamically imported module\"\n    });\n    expect(text).toMatch(/Could not download Firebase SDK modules/i);\n  });\n\n  test(\"falls back to code-based generic message\", () => {\n    const text = formatMultiplayerJoinError({ code: \"some-unknown-code\" });\n    expect(text).toMatch(/some-unknown-code/);\n  });\n\n  test(\"uses plain generic message with no code\", () => {\n    const text = formatMultiplayerJoinError(new Error(\"plain\"));\n    expect(text).toBe(\"Failed to connect to multiplayer. Check Firebase config/network.\");\n  });\n});\n"
  },
  {
    "path": "tests/game-engine.test.js",
    "content": "import { jest } from \"@jest/globals\";\nimport { HAZARDS, STAGES, UI_TEXT } from \"../src/game/constants.js\";\nimport { GameEngine } from \"../src/game/game-engine.js\";\nimport { cellKey } from \"../src/game/grid.js\";\n\nfunction buildSource(lines = 30) {\n  const row = \"{ } ( ) [ ] ; = < > function run() { return 42; } // comment\";\n  return Array.from({ length: lines }, () => row).join(\"\\n\");\n}\n\nfunction createRendererMock({ measuredBoardSize = null } = {}) {\n  return {\n    updateStatus: jest.fn(),\n    updateAudioStatus: jest.fn(),\n    setMessage: jest.fn(),\n    renderBoard: jest.fn(),\n    triggerGlitch: jest.fn(),\n    measureBoardSize: jest.fn(() => measuredBoardSize)\n  };\n}\n\nfunction createAudioMock({ enabled = true } = {}) {\n  return {\n    isEnabled: jest.fn(() => enabled),\n    ensureEnabledForGameplay: jest.fn(() => Promise.resolve()),\n    toggle: jest.fn(() => Promise.resolve()),\n    setPlaybackActive: jest.fn(),\n    setGameSpeed: jest.fn(),\n    dispose: jest.fn(),\n    playStartSfx: jest.fn(),\n    playEatSfx: jest.fn(),\n    playCrashSfx: jest.fn()\n  };\n}\n\nfunction createEngine(options = {}) {\n  const renderer = createRendererMock({\n    measuredBoardSize: options.measuredBoardSize ?? null\n  });\n  const audio = createAudioMock({ enabled: options.audioEnabled ?? true });\n  const engine = new GameEngine({\n    renderer,\n    audio,\n    sourceProvider: options.sourceProvider,\n    sourceText: options.sourceText ?? buildSource()\n  });\n\n  return { engine, renderer, audio };\n}\n\ndescribe(\"GameEngine\", () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  test(\"reset initializes board, HUD, and ready message\", () => {\n    const { engine, renderer } = createEngine();\n\n    engine.reset();\n\n    expect(engine.state.running).toBe(false);\n    expect(engine.state.gameOver).toBe(false);\n    expect(engine.state.activeTargets.size).toBeGreaterThan(0);\n\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.ready);\n    expect(renderer.updateStatus).toHaveBeenCalled();\n    expect(renderer.renderBoard).toHaveBeenCalled();\n\n    const lastHud = renderer.updateStatus.mock.calls.at(-1)[0];\n    expect(lastHud.stage).toBe(1);\n    expect(lastHud.targetChar.length).toBeGreaterThan(0);\n    expect(lastHud.targetChar).toContain(\"{\");\n  });\n\n  test(\"reset uses renderer-measured board size when available\", () => {\n    const { engine } = createEngine({ measuredBoardSize: { width: 40, height: 18 } });\n\n    engine.reset();\n\n    expect(engine.boardSize).toEqual({ width: 40, height: 18 });\n    expect(engine.codeGrid.length).toBe(18);\n    expect(engine.codeGrid[0].length).toBe(40);\n  });\n\n  test(\"uses custom source provider when supplied\", () => {\n    const sourceProvider = { nextSource: jest.fn(() => \"{ provider-source }\") };\n    const { engine } = createEngine({ sourceProvider });\n\n    engine.reset();\n\n    expect(sourceProvider.nextSource).toHaveBeenCalled();\n    expect(engine.currentSourceText).toContain(\"provider-source\");\n  });\n\n  test(\"start begins loop and triggers start SFX\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.start();\n\n    expect(engine.state.running).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(true);\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(audio.playStartSfx).toHaveBeenCalledTimes(1);\n    expect(jest.getTimerCount()).toBeGreaterThan(0);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toMatch(/^Stage 1 \\| Corrupt/);\n  });\n\n  test(\"stopLoop clears the active loop interval\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n    engine.start();\n    expect(engine.interval).not.toBeNull();\n\n    engine.stopLoop();\n    expect(engine.interval).toBeNull();\n  });\n\n  test(\"start asks audio engine to enable when currently disabled\", () => {\n    const { engine, audio } = createEngine({ audioEnabled: false });\n    engine.reset();\n\n    engine.start();\n\n    expect(audio.ensureEnabledForGameplay).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"setDirection queues rapid turns and blocks reversals\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([]);\n\n    engine.setDirection(0, -1);\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n\n    engine.setDirection(1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n  });\n\n  test(\"tick ends the game on wall collision\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 0, y: 0 }];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.crash);\n  });\n\n  test(\"tick ends the game on self-collision\", () => {\n    const { engine, audio } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [\n      { x: 2, y: 2 },\n      { x: 3, y: 2 },\n      { x: 3, y: 3 },\n      { x: 2, y: 3 }\n    ];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"tick consumes target cells and updates progression state\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n\n    const oldScore = engine.state.score;\n    const oldLength = engine.state.snake.length;\n\n    engine.tick();\n\n    expect(engine.state.eaten.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.corruptedChars.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.eatenCount).toBe(1);\n    expect(engine.state.eatenThisTarget).toBeGreaterThanOrEqual(0);\n    expect(engine.state.score).toBeGreaterThan(oldScore);\n    expect(engine.state.speed).toBeGreaterThan(1);\n    expect(engine.state.snake.length).toBe(oldLength + 1);\n\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(renderer.triggerGlitch).toHaveBeenCalledTimes(1);\n    expect(audio.playEatSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"corruption threshold level-up advances stage and swaps code source\", () => {\n    const sourceProvider = {\n      nextSource: jest.fn()\n        .mockReturnValueOnce(\n          \"// source: alpha.js\\n// region: 1-8\\n{ } ( ) [ ] ; = < > a e i o u s r t n l c d m f\"\n        )\n        .mockReturnValueOnce(\n          \"// source: beta.js\\n// region: 1-8\\nfunction beta(){return safe_token + glitch_mask;}\"\n        )\n    };\n    const { engine } = createEngine({\n      measuredBoardSize: { width: 24, height: 12 },\n      sourceProvider\n    });\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n    engine.state.eatenCount = STAGES.corruptionsPerLevel - 1;\n\n    engine.tick();\n\n    expect(engine.state.stage).toBe(2);\n    expect(sourceProvider.nextSource).toHaveBeenCalledTimes(2);\n    expect(engine.currentSourcePath).toBe(\"beta.js\");\n    expect(engine.state.activeTargets.size).toBeGreaterThan(0);\n    expect(engine.state.eaten.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.corruptedChars.has(cellKey(2, 1))).toBe(true);\n  });\n\n  test(\"tick decrements growth on empty movement and keeps tail length\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 1;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.growth).toBe(0);\n    expect(engine.state.snake.length).toBe(beforeLength + 1);\n  });\n\n  test(\"tick pops tail on empty movement when no growth remains\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 0;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.snake.length).toBe(beforeLength);\n  });\n\n  test(\"consuming the final quota target rotates to the next target set\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n    engine.state.targetQuota = 1;\n    engine.state.eatenThisTarget = 0;\n    const previousTarget = engine.state.currentTargetIndex;\n\n    engine.tick();\n\n    expect(engine.state.currentTargetIndex).not.toBe(previousTarget);\n    expect(engine.state.eatenThisTarget).toBe(0);\n  });\n\n  test(\"pickNextTargets reports full corruption when no targets remain\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.eaten.add(\"0,0\");\n    engine.state.activeTargets.clear();\n\n    const found = engine.pickNextTargets();\n\n    expect(found).toBe(false);\n    expect(engine.state.gameOver).toBe(true);\n    expect(engine.state.won).toBe(true);\n    expect(engine.audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"hazard collision ends game with hazard-specific message\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 2, y: 2 }];\n    engine.state.hazardCells = new Set([cellKey(3, 2)]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.hazardCrash);\n  });\n\n  test(\"collision with corrupted code ends game with corruption-specific message\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 4, y: 4 }];\n    engine.state.eaten = new Set([cellKey(5, 4)]);\n    engine.state.corruptedChars.set(cellKey(5, 4), \"#\");\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.corruptionCrash);\n  });\n\n  test(\"remote snake collision ends game and ejects the local player\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 2, y: 2 }];\n    engine.setRemotePlayers([\n      { id: \"other-1\", name: \"Other\", score: 10, snake: [{ x: 3, y: 2 }] }\n    ]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(engine.state.gameOverReason).toBe(\"player\");\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.playerCrash);\n  });\n\n  test(\"refreshHazards creates avoid cells as progression increases\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = HAZARDS.unlockAtEaten + HAZARDS.growthStep * 2;\n    engine.state.activeTargets = new Set();\n    engine.state.hazardCells = new Set([\"0,0\"]);\n    engine.state.snake = [{ x: 10, y: 10 }];\n\n    engine.refreshHazards(true);\n\n    expect(engine.state.activeHazardChars.length).toBeGreaterThan(0);\n    expect(engine.state.hazardCells.size).toBeGreaterThan(0);\n  });\n\n  test(\"refreshHazards clears existing hazards when below unlock threshold\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = 0;\n    engine.state.hazardCells = new Set([\"1,1\", \"2,2\"]);\n    engine.state.activeHazardChars = [\":\", \".\"];\n\n    engine.refreshHazards();\n\n    expect(engine.state.hazardCells.size).toBe(0);\n    expect(engine.state.activeHazardChars).toEqual([]);\n  });\n\n  test(\"label helpers handle empty and populated states\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.activeTargetChars = [];\n    engine.state.currentTargetIndex = 0;\n    expect(engine.currentTargetLabel()).toBe(\"{\");\n\n    engine.state.activeHazardChars = [];\n    expect(engine.currentAvoidLabel()).toBe(\"-\");\n\n    engine.state.activeTargetChars = [\"{\", \"}\", \";\"];\n    engine.state.activeHazardChars = [\":\", \".\"];\n    expect(engine.currentTargetLabel()).toBe(\"{ } ;\");\n    expect(engine.currentAvoidLabel()).toBe(\": .\");\n  });\n\n  test(\"tick keeps full-corruption message when terminal state happens mid-tick\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 0 }];\n    engine.state.activeTargets = new Set([\"0,0\"]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toBe(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"toggleAudio and dispose delegate to audio engine\", () => {\n    const { engine, audio } = createEngine();\n\n    engine.toggleAudio();\n    engine.dispose();\n\n    expect(audio.toggle).toHaveBeenCalledTimes(1);\n    expect(audio.dispose).toHaveBeenCalledTimes(1);\n  });\n});\n"
  },
  {
    "path": "tests/game-state.test.js",
    "content": "import { START_DIRECTION } from \"../src/game/constants.js\";\nimport { createInitialState } from \"../src/game/game-state.js\";\n\ndescribe(\"createInitialState\", () => {\n  test(\"creates expected defaults and centered snake\", () => {\n    const state = createInitialState(20, 10);\n\n    expect(state.score).toBe(0);\n    expect(state.stage).toBe(1);\n    expect(state.eatenCount).toBe(0);\n    expect(state.speed).toBe(1);\n    expect(state.running).toBe(false);\n    expect(state.gameOver).toBe(false);\n    expect(state.gameOverReason).toBe(null);\n    expect(state.won).toBe(false);\n\n    expect(state.direction).toEqual(START_DIRECTION);\n    expect(state.queuedDirection).toEqual(START_DIRECTION);\n    expect(state.directionQueue).toEqual([]);\n    expect(state.corruptedChars.size).toBe(0);\n    expect(state.snake).toEqual([\n      { x: 9, y: 5 },\n      { x: 8, y: 5 },\n      { x: 7, y: 5 }\n    ]);\n  });\n\n  test(\"returns fresh mutable collections per call\", () => {\n    const a = createInitialState(20, 10);\n    const b = createInitialState(20, 10);\n\n    a.eaten.add(\"1,1\");\n    a.corruptedChars.set(\"1,1\", \"#\");\n    a.activeTargets.add(\"2,2\");\n    a.direction.x = 999;\n\n    expect(b.eaten.size).toBe(0);\n    expect(b.corruptedChars.size).toBe(0);\n    expect(b.activeTargets.size).toBe(0);\n    expect(b.direction).toEqual(START_DIRECTION);\n  });\n});\n"
  },
  {
    "path": "tests/grid.test.js",
    "content": "import {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"../src/game/grid.js\";\n\ndescribe(\"grid utilities\", () => {\n  test(\"buildCodeGrid pads and truncates lines to requested dimensions\", () => {\n    const grid = buildCodeGrid(\"abc\\nlonger-than-width\\n\", 5, 3);\n\n    expect(grid).toEqual([\n      [\"a\", \"b\", \"c\", \" \", \" \"],\n      [\"l\", \"o\", \"n\", \"g\", \"e\"],\n      [\" \", \" \", \" \", \" \", \" \"]\n    ]);\n  });\n\n  test(\"cellKey creates stable key strings\", () => {\n    expect(cellKey(10, 4)).toBe(\"10,4\");\n  });\n\n  test(\"inBounds checks coordinates correctly\", () => {\n    expect(inBounds(0, 0, 3, 3)).toBe(true);\n    expect(inBounds(2, 2, 3, 3)).toBe(true);\n    expect(inBounds(-1, 0, 3, 3)).toBe(false);\n    expect(inBounds(0, 3, 3, 3)).toBe(false);\n    expect(inBounds(3, 0, 3, 3)).toBe(false);\n  });\n\n  test(\"shuffled returns a new array with same values\", () => {\n    const input = [\"a\", \"b\", \"c\", \"d\"];\n    const result = shuffled(input);\n\n    expect(result).not.toBe(input);\n    expect(result.slice().sort()).toEqual(input.slice().sort());\n  });\n\n  test(\"collectTargetCandidates returns only non-eaten matches\", () => {\n    const grid = [\n      [\"{\", \"x\", \"{\"],\n      [\"}\", \"{\", \"y\"]\n    ];\n    const eaten = new Set([\"2,0\"]);\n\n    expect(collectTargetCandidates(grid, \"{\", eaten).sort()).toEqual([\"0,0\", \"1,1\"]);\n    expect(collectTargetCandidates(grid, \"}\", eaten)).toEqual([\"0,1\"]);\n  });\n});\n"
  },
  {
    "path": "tests/multiplayer-session.test.js",
    "content": "import { jest } from \"@jest/globals\";\nimport { MultiplayerSession } from \"../src/network/multiplayer-session.js\";\n\nfunction createBackendMock() {\n  let callback = () => {};\n  return {\n    joinRoom: jest.fn(async () => ({ roomId: \"room-a\", playerId: \"player-a\" })),\n    leaveRoom: jest.fn(async () => {}),\n    updatePlayerState: jest.fn(async () => {}),\n    subscribeToRoomPlayers: jest.fn((roomId, onPlayers) => {\n      callback = onPlayers;\n      return () => {\n        callback = () => {};\n      };\n    }),\n    emit(players) {\n      callback(players);\n    }\n  };\n}\n\ndescribe(\"MultiplayerSession\", () => {\n  test(\"requires non-empty player name on join\", async () => {\n    const backend = createBackendMock();\n    const session = new MultiplayerSession({ backend });\n\n    await expect(session.join(\"   \")).rejects.toThrow(\"Player name is required.\");\n  });\n\n  test(\"join subscribes to players and exposes remote snakes\", async () => {\n    const backend = createBackendMock();\n    const onPlayersChanged = jest.fn();\n    const session = new MultiplayerSession({ backend, onPlayersChanged });\n\n    await session.join(\"Alice\");\n    backend.emit([\n      { id: \"player-a\", name: \"Alice\", score: 11, status: \"active\", snake: [{ x: 1, y: 1 }] },\n      { id: \"player-b\", name: \"Bob\", score: 7, status: \"active\", snake: [{ x: 2, y: 2 }] }\n    ]);\n\n    expect(session.isJoined()).toBe(true);\n    expect(onPlayersChanged).toHaveBeenCalled();\n    expect(session.getRemoteSnakePlayers()).toEqual([\n      {\n        id: \"player-b\",\n        name: \"Bob\",\n        score: 7,\n        stage: 1,\n        gameOver: false,\n        snake: [{ x: 2, y: 2 }]\n      }\n    ]);\n  });\n\n  test(\"pushState deduplicates unchanged payloads\", async () => {\n    const backend = createBackendMock();\n    const session = new MultiplayerSession({ backend });\n\n    await session.join(\"Alice\");\n    const state = {\n      score: 12,\n      stage: 2,\n      running: true,\n      gameOver: false,\n      gameOverReason: null,\n      snake: [{ x: 1, y: 1 }]\n    };\n\n    session.pushState(state);\n    session.pushState(state);\n    expect(backend.updatePlayerState).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"leave clears local state and calls backend\", async () => {\n    const backend = createBackendMock();\n    const onRoomChanged = jest.fn();\n    const session = new MultiplayerSession({ backend, onRoomChanged });\n\n    await session.join(\"Alice\");\n    await session.leave(\"disconnect\");\n\n    expect(session.isJoined()).toBe(false);\n    expect(backend.leaveRoom).toHaveBeenCalledWith({\n      roomId: \"room-a\",\n      playerId: \"player-a\",\n      reason: \"disconnect\"\n    });\n    expect(onRoomChanged).toHaveBeenLastCalledWith(null);\n  });\n});\n"
  },
  {
    "path": "tests/room-logic.test.js",
    "content": "import {\n  chooseRoomForJoin,\n  getRemoteSnakePlayers,\n  normalizePlayerName,\n  normalizeRoomPlayers\n} from \"../src/network/room-logic.js\";\n\ndescribe(\"room-logic\", () => {\n  test(\"normalizePlayerName trims, condenses whitespace, and truncates\", () => {\n    expect(normalizePlayerName(\"   \")).toBe(\"\");\n    expect(normalizePlayerName(\"  Alice   Bob  \")).toBe(\"Alice Bob\");\n    expect(normalizePlayerName(\"abcdefghijklmnopqrstuvwxyz\")).toHaveLength(20);\n  });\n\n  test(\"chooseRoomForJoin picks least-populated eligible room\", () => {\n    const chosen = chooseRoomForJoin([\n      { id: \"room-1\", activeCount: 4, updatedAt: 10 },\n      { id: \"room-2\", activeCount: 1, updatedAt: 20 },\n      { id: \"room-3\", activeCount: 3, updatedAt: 15 }\n    ], 5);\n\n    expect(chosen.id).toBe(\"room-2\");\n  });\n\n  test(\"chooseRoomForJoin returns null when no room has capacity\", () => {\n    const chosen = chooseRoomForJoin([\n      { id: \"room-1\", activeCount: 5 },\n      { id: \"room-2\", activeCount: 8 }\n    ], 5);\n\n    expect(chosen).toBeNull();\n  });\n\n  test(\"normalizeRoomPlayers removes left players and coerces fields\", () => {\n    const players = normalizeRoomPlayers([\n      { id: \"1\", name: \" Alice \", score: \"12\", stage: \"3\", status: \"active\", snake: [{ x: 1, y: 1 }] },\n      { id: \"2\", name: \"Bob\", score: 9, status: \"left\", snake: [{ x: 2, y: 2 }] },\n      { id: \"3\", name: \"\", score: null, stage: null, status: \"active\", snake: \"bad\" }\n    ]);\n\n    expect(players).toEqual([\n      {\n        id: \"1\",\n        name: \"Alice\",\n        score: 12,\n        stage: 3,\n        gameOver: false,\n        snake: [{ x: 1, y: 1 }]\n      },\n      {\n        id: \"3\",\n        name: \"anonymous\",\n        score: 0,\n        stage: 1,\n        gameOver: false,\n        snake: []\n      }\n    ]);\n  });\n\n  test(\"getRemoteSnakePlayers returns only non-local active snakes\", () => {\n    const remotes = getRemoteSnakePlayers([\n      { id: \"self\", name: \"Me\", score: 5, gameOver: false, status: \"active\", snake: [{ x: 1, y: 1 }] },\n      { id: \"r1\", name: \"R1\", score: 2, gameOver: false, status: \"active\", snake: [{ x: 2, y: 2 }] },\n      { id: \"r2\", name: \"R2\", score: 2, gameOver: true, status: \"active\", snake: [{ x: 3, y: 3 }] },\n      { id: \"r3\", name: \"R3\", score: 2, gameOver: false, status: \"active\", snake: [] }\n    ], \"self\");\n\n    expect(remotes).toEqual([\n      {\n        id: \"r1\",\n        name: \"R1\",\n        score: 2,\n        stage: 1,\n        gameOver: false,\n        snake: [{ x: 2, y: 2 }]\n      }\n    ]);\n  });\n});\n"
  },
  {
    "path": "tests/source-text.test.js",
    "content": "import { SourceTextProvider } from \"../src/game/source-text.js\";\n\ndescribe(\"SourceTextProvider\", () => {\n  test(\"returns source text windows with metadata header\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"one\\ntwo\\nthree\\nfour\" }\n    ]);\n\n    const snippet = provider.nextSource({ width: 80, height: 4 });\n    const lines = snippet.split(\"\\n\");\n\n    expect(lines[0]).toMatch(/^\\/\\/ source: a\\.js/);\n    expect(lines[1]).toMatch(/^\\/\\/ region: /);\n    expect(lines.length).toBe(4);\n  });\n\n  test(\"avoids repeating identical pick when multiple corpus entries exist\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"alpha\\nbeta\\ngamma\" },\n      { path: \"b.js\", content: \"delta\\nepsilon\\nzeta\" }\n    ]);\n\n    const first = provider.nextSource({ width: 80, height: 4 });\n    const second = provider.nextSource({ width: 80, height: 4 });\n\n    expect(first).not.toBe(second);\n  });\n});\n"
  },
  {
    "path": "tests/syntax-highlighter.test.js",
    "content": "import { KEYWORDS } from \"../src/game/constants.js\";\nimport { buildStyleGrid } from \"../src/game/syntax-highlighter.js\";\n\nfunction lineToGrid(line) {\n  return [line.split(\"\")];\n}\n\ndescribe(\"buildStyleGrid\", () => {\n  test(\"highlights keywords and function identifiers\", () => {\n    const line = \"const run = move();\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles.slice(0, 5).every((s) => s === \"tk-keyword\")).toBe(true);\n    expect(styles[line.indexOf(\"move\")]).toBe(\"tk-function\");\n  });\n\n  test(\"highlights strings and numbers\", () => {\n    const line = \"let value = \\\"hi\\\" + 10_5;\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"let\")]).toBe(\"tk-keyword\");\n    expect(styles[line.indexOf('\"')]).toBe(\"tk-string\");\n    expect(styles[line.indexOf(\"1\")]).toBe(\"tk-number\");\n  });\n\n  test(\"highlights comments until line end\", () => {\n    const line = \"x = 2; // todo\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n    const commentStart = line.indexOf(\"//\");\n\n    expect(styles[commentStart]).toBe(\"tk-comment\");\n    expect(styles.slice(commentStart).every((s) => s === \"tk-comment\")).toBe(true);\n  });\n\n  test(\"marks punctuation tokens\", () => {\n    const line = \"{ a: (b + c) }\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"{\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\":\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\"+\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\")\")]).toBe(\"tk-punct\");\n  });\n});\n"
  }
];
