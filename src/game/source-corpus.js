// Auto-generated by scripts/generate-source-corpus.mjs
// Do not edit manually.

export const SOURCE_CORPUS = [
  {
    "path": "AGENTS.md",
    "content": "## Do's\n\n- Follow best coding practices like SOLID and DRY\n- Keep the codebase well structured and well organised\n- Document as you go - add any useful documentation to a dedicated /docs folder\n"
  },
  {
    "path": "README.md",
    "content": "# Code Virus\n\nCode Virus is a browser game inspired by classic Snake.\nInstead of eating food on an empty board, you control a virus that corrupts characters inside a live code block rendered in an IDE-style interface.\n\n## Features\n- IDE-themed game board built from source code text.\n- Target-character gameplay loop (`{}`, `()`, `[]`, `;`, `=`, `<`, `>`).\n- Progressive difficulty (snake growth + speed scaling).\n- Syntax-highlighted code rendering.\n- Visual glitch effects on corruption events.\n- Synthesized sound effects and background music via Web Audio API.\n\n## Project Structure\n```text\nsnake-code/\n  index.html\n  src/\n    main.js\n    styles/\n      main.css\n    game/\n      audio-engine.js\n      constants.js\n      game-engine.js\n      game-state.js\n      grid.js\n      input-controller.js\n      renderer.js\n      source-text.js\n      syntax-highlighter.js\n  tests/\n    game-engine.test.js\n    game-state.test.js\n    grid.test.js\n    syntax-highlighter.test.js\n  docs/\n    architecture.md\n    game-notes.md\n```\n\n## Getting Started\n### Prerequisites\n- Node.js 20+ (recommended)\n- npm 10+\n- Python 3 (for local static hosting)\n\n### Install\n```bash\nnpm install\n```\n\n### Run Locally\n```bash\nnpm run run\n```\nThen open:\n- `http://localhost:8000`\n\nNote: The app uses browser ES modules, so run through a local server (not `file://`).\n\n## Controls\n- `Arrow keys` / `W A S D`: move\n- `Space` or `Enter`: start / restart\n- `M`: toggle audio\n\n## Scripts\n- `npm run run`: serve app with Python on port `8000`\n- `npm test`: run Jest unit tests\n- `npm run test:watch`: run tests in watch mode\n- `npm run test:coverage`: run tests with coverage output\n\n## Testing Strategy\nUnit tests cover:\n- Grid utilities and candidate selection logic.\n- Syntax highlighting classification behavior.\n- Initial state creation.\n- Core game-engine behavior (start/reset/tick/collisions/scoring/terminal states).\n\nCoverage reports are generated in:\n- Console summary (`text`)\n- `coverage/lcov-report/index.html`\n- `coverage/lcov.info`\n\n## Engineering Notes\n- Game rules are centralized in `src/game/game-engine.js`.\n- Rendering is isolated in `src/game/renderer.js`.\n- Audio concerns are encapsulated in `src/game/audio-engine.js`.\n- Input emits intent only, via `src/game/input-controller.js`.\n\nSee `docs/architecture.md` for module boundaries and design rationale.\n\n## Troubleshooting\n- If the app does not load scripts, confirm you are serving via `npm run run`.\n- If tests fail due to environment issues, verify Node version (`node -v`) and reinstall dependencies (`npm install`).\n\n## License\nISC\n"
  },
  {
    "path": "docs/architecture.md",
    "content": "# Code Virus Architecture\n\n## Overview\nThe app is intentionally split into small, single-purpose modules so game rules, rendering, audio, and input are isolated and easier to maintain.\nBecause the app uses browser ES modules, run it through a static server if your browser blocks `file://` module loading.\nArchitecture and tradeoff decisions are recorded in `docs/decisions.md`.\n\n## File Map\n- `index.html`: semantic shell only, no inline CSS or gameplay logic.\n- `src/styles/main.css`: all presentation styles.\n- `src/main.js`: composition root that wires dependencies and bootstraps the app.\n- `scripts/generate-source-corpus.mjs`: builds runtime source corpus from repository files.\n\n## Game Modules (`src/game`)\n- `constants.js`: gameplay/system constants and UI copy.\n- `source-text.js`: code block content used as the in-game map.\n- `source-corpus.js`: generated corpus of repository files consumed by the source provider.\n- `game-state.js`: initial state factory.\n- `grid.js`: pure grid utilities (bounds, keying, target discovery, shuffling).\n- `syntax-highlighter.js`: pure token-class derivation for syntax coloring.\n- `renderer.js`: DOM rendering + HUD updates + glitch visual effect.\n- `audio-engine.js`: Web Audio lifecycle, SFX, and music loop.\n- `input-controller.js`: keyboard mapping and event binding.\n- `game-engine.js`: core game loop, collision rules, scoring, growth, target rotation, and orchestration.\n\n## Boundaries\n- `game-engine.js` owns game state and timing.\n- `renderer.js` receives state snapshots and draws; it does not own game rules.\n- `audio-engine.js` is event-driven by the engine; gameplay logic does not depend on Web Audio internals.\n- `input-controller.js` only emits intents (direction/start/toggle), keeping controls decoupled from rules.\n- Source selection is abstracted behind a provider so gameplay logic does not depend on filesystem APIs.\n"
  },
  {
    "path": "docs/decisions.md",
    "content": "# Decisions Log\n\n## 2026-02-15\n\n### Decision: Add direction input buffering (queue length 2)\n- Context: Rapid sequential key presses were collapsing to a single direction update, making sharp turns unreliable.\n- Decision: Store up to two upcoming directions and validate each new input against the current queued tail.\n- Consequence: Players can perform tight turns reliably while still blocking illegal immediate reversals.\n\n### Decision: Make play-area bounds dynamic to editor viewport\n- Context: Fixed grid dimensions made collision boundaries feel disconnected from the visible play area.\n- Decision: Measure character metrics and editor viewport in the renderer, then derive runtime board width/height.\n- Consequence: Collision edges now align with the visible editor panel edges (which now fill the window).\n\n### Decision: Tie music tempo to game speed and stop playback on game-over\n- Context: Audio intensity did not track gameplay pacing and continued through terminal states.\n- Decision: Introduce `setGameSpeed` and `setPlaybackActive` in the audio engine, and drive both from game state transitions.\n- Consequence: Music accelerates as player speed increases and stops when the run ends.\n\n### Decision: Normalize corrupted-cell visual to true background\n- Context: Eaten-character holes had visible tinting relative to the editor background.\n- Decision: Render hole cells with transparent background and transparent text.\n- Consequence: Corrupted characters visually disappear cleanly without residual tint artifacts.\n\n### Decision: Increase target character prominence\n- Context: Targets could be lost in syntax-highlighted text at speed.\n- Decision: Strengthen target styling using brighter background, outline/glow, and pulse animation.\n- Consequence: Targets remain clearly distinguishable from regular syntax tokens.\n\n### Decision: Keep centered virtual window while preserving edge-aligned play bounds\n- Context: Full-viewport virtual window removed desired page framing/spacing.\n- Decision: Revert to centered virtual window styling and retain dynamic board sizing based on editor viewport.\n- Consequence: The snake still reaches the rendered window's visible editor edges, while the virtual window remains centered inside the real browser window.\n\n### Decision: Source map content from generated real repository corpus\n- Context: Static hardcoded code blocks reduced replay value and did not reflect the actual project.\n- Decision: Add `scripts/generate-source-corpus.mjs` to generate `src/game/source-corpus.js`, and select random source windows per run.\n- Consequence: Each play session can render a different real code slice while remaining browser-only at runtime.\n\n### Decision: Introduce progressive hazard cells separate from target cells\n- Context: Gameplay needed additional pressure and failure modes beyond walls/self-collision.\n- Decision: Add hazard character classes that unlock after early progression and scale in density over time.\n- Consequence: Runs become more challenging as corruption progresses; touching a hazard ends the run.\n\n### Decision: Promote multi-target cycles instead of single active target char\n- Context: Single-target loops could feel sparse and repetitive at higher speed.\n- Decision: Activate multiple target character classes simultaneously, with per-cycle quotas and dynamic spawn volume.\n- Consequence: More actionable targets are present at any moment, improving flow and reducing dead movement.\n"
  },
  {
    "path": "docs/game-notes.md",
    "content": "# Code Virus Game Notes\n\n## Current Controls\n- `Arrow keys` or `W/A/S/D`: move virus.\n- `Space` or `Enter`: start/restart run.\n- `M`: toggle audio (SFX + background track).\n\n## Rendering Rules\n- The game board is sourced from real repository files via `src/game/source-corpus.js`.\n- A different source slice is selected each run/reset.\n- The virtual IDE window is centered in the browser page with surrounding spacing.\n- Editor typography keeps standard code-like spacing (non-square glyph geometry).\n- Corrupted characters are replaced with whitespace holes (blank cells).\n- Play-area dimensions are measured from the editor viewport so bounds align with visible panel edges.\n\n## Movement Timing\n- The game uses one shared movement speed for all directions.\n- Speed increases as the virus corrupts more target characters.\n- Direction input is buffered (short queue) to preserve rapid turn intent.\n\n## Highlighting Rules\n- Lightweight JavaScript-style syntax highlighting is applied per character cell.\n- Highlight classes include keyword, string, number, comment, function name, and punctuation.\n- Active target characters always override syntax color to remain readable.\n- Hazard characters are highlighted in red and must be avoided.\n\n## Targeting Rules\n- Multiple target character classes are active at the same time.\n- As progression increases, more target classes and more active target cells are spawned.\n- A target cycle completes after a quota of successful corruptions, then a new target set is selected.\n\n## Hazard Rules\n- Hazard characters unlock after an early progression threshold.\n- Hazard density increases as more code is corrupted.\n- Touching a hazard cell ends the run immediately.\n\n## Audio\n- Audio is generated with Web Audio API oscillators (no external assets).\n- Eat, start, and crash events each trigger short synthesized SFX.\n- A low-volume looping pattern runs while audio is enabled and gameplay is active.\n- Music tempo scales up with player speed and stops on game over.\n\n## Structure\n- `index.html` is a thin shell for layout containers and IDs.\n- `src/styles/main.css` contains all styling.\n- `src/main.js` is the bootstrap/assembly entrypoint.\n- Gameplay is split into dedicated modules under `src/game/` (engine, renderer, audio, input, syntax, grid, constants, state).\n- Real source-code corpus generation is handled by `scripts/generate-source-corpus.mjs`.\n- Architecture/design decisions are logged in `docs/decisions.md`.\n"
  },
  {
    "path": "index.html",
    "content": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Code Virus: Snake</title>\n    <link rel=\"stylesheet\" href=\"./src/styles/main.css\" />\n  </head>\n  <body>\n    <div class=\"app\" id=\"app\">\n      <div class=\"titlebar\">\n        <div class=\"lights\">\n          <span class=\"light r\"></span>\n          <span class=\"light y\"></span>\n          <span class=\"light g\"></span>\n        </div>\n        <span>code-virus.ts</span>\n      </div>\n      <div class=\"workspace\">\n        <aside class=\"hud\">\n          <h1>Code Virus</h1>\n          <div class=\"status\">\n            <div class=\"item\">\n              <div class=\"k\">Score</div>\n              <div class=\"v\" id=\"score\">0</div>\n            </div>\n            <div class=\"item\">\n              <div class=\"k\">Targets</div>\n              <div class=\"v\" id=\"targetChar\">{ }</div>\n            </div>\n            <div class=\"item\">\n              <div class=\"k\">Avoid</div>\n              <div class=\"v\" id=\"avoidChars\">-</div>\n            </div>\n            <div class=\"item\">\n              <div class=\"k\">Corrupted</div>\n              <div class=\"v\" id=\"eaten\">0</div>\n            </div>\n            <div class=\"item\">\n              <div class=\"k\">Speed</div>\n              <div class=\"v\" id=\"speed\">1.0x</div>\n            </div>\n            <div class=\"item\">\n              <div class=\"k\">Audio</div>\n              <div class=\"v\" id=\"audioStatus\">OFF</div>\n            </div>\n          </div>\n          <div class=\"help\">\n            Arrow keys / WASD to steer.<br />\n            Eat highlighted target characters.<br />\n            Avoid red protected characters.<br />\n            Avoid your own virus tail and editor bounds.<br />\n            Press M to toggle audio.\n          </div>\n          <div class=\"cta\" id=\"message\">\n            Press Space to deploy virus.\n          </div>\n        </aside>\n        <section class=\"editor-wrap\">\n          <div class=\"editor-head\">\n            <span>main</span>\n            <span>virus-engine.ts</span>\n            <span>UTF-8</span>\n          </div>\n          <pre id=\"editor\"></pre>\n        </section>\n      </div>\n    </div>\n\n    <script type=\"module\" src=\"./src/main.js\"></script>\n  </body>\n</html>\n"
  },
  {
    "path": "jest.config.js",
    "content": "export default {\n  testEnvironment: \"node\",\n  watchman: false,\n  roots: [\"<rootDir>/tests\"],\n  testMatch: [\"**/*.test.js\"],\n  collectCoverageFrom: [\n    \"src/game/constants.js\",\n    \"src/game/game-state.js\",\n    \"src/game/grid.js\",\n    \"src/game/syntax-highlighter.js\",\n    \"src/game/game-engine.js\"\n  ],\n  coverageReporters: [\"text\", \"lcov\", \"html\"],\n  coverageThreshold: {\n    global: {\n      statements: 85,\n      branches: 80,\n      functions: 85,\n      lines: 85\n    }\n  }\n};\n"
  },
  {
    "path": "package.json",
    "content": "{\n  \"name\": \"snake-code\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Code Virus: a snake-inspired browser game where you corrupt source code in an IDE-style interface.\",\n  \"private\": true,\n  \"license\": \"ISC\",\n  \"author\": \"\",\n  \"type\": \"module\",\n  \"main\": \"src/main.js\",\n  \"directories\": {\n    \"doc\": \"docs\"\n  },\n  \"scripts\": {\n    \"generate:source\": \"node scripts/generate-source-corpus.mjs\",\n    \"run\": \"python -m http.server 8000\",\n    \"prestart\": \"npm run generate:source\",\n    \"start\": \"python -m http.server 8000\",\n    \"pretest\": \"npm run generate:source\",\n    \"test\": \"node --experimental-vm-modules ./node_modules/jest/bin/jest.js\",\n    \"test:watch\": \"node --experimental-vm-modules ./node_modules/jest/bin/jest.js --watch\",\n    \"test:coverage\": \"node --experimental-vm-modules ./node_modules/jest/bin/jest.js --coverage\"\n  },\n  \"devDependencies\": {\n    \"jest\": \"^30.2.0\"\n  }\n}\n"
  },
  {
    "path": "src/game/audio-engine.js",
    "content": "export class AudioEngine {\n  constructor(onStatusChange = () => {}) {\n    this.onStatusChange = onStatusChange;\n    this.enabled = false;\n    this.playbackActive = false;\n    this.speedMultiplier = 1;\n    this.audioCtx = null;\n    this.musicTimer = null;\n    this.musicStep = 0;\n    this.notifyStatus();\n  }\n\n  isEnabled() {\n    return this.enabled;\n  }\n\n  async toggle() {\n    if (this.enabled) {\n      this.disable();\n      return;\n    }\n\n    await this.enable(true);\n  }\n\n  async ensureEnabledForGameplay() {\n    if (this.enabled) return;\n    await this.enable(false);\n  }\n\n  setPlaybackActive(active) {\n    this.playbackActive = active;\n    if (this.playbackActive) {\n      this.startMusic();\n      return;\n    }\n    this.stopMusic();\n  }\n\n  setGameSpeed(multiplier) {\n    this.speedMultiplier = Math.max(1, Number(multiplier) || 1);\n    if (this.musicTimer) this.restartMusic();\n  }\n\n  playStartSfx() {\n    this.playTone({ freq: this.noteToHz(64), duration: 0.06, type: \"square\", gain: 0.02 });\n    this.playTone({\n      freq: this.noteToHz(71),\n      duration: 0.08,\n      type: \"square\",\n      gain: 0.02,\n      when: 0.06\n    });\n  }\n\n  playEatSfx() {\n    this.playTone({ freq: this.noteToHz(76), duration: 0.07, type: \"triangle\", gain: 0.025 });\n    this.playTone({\n      freq: this.noteToHz(83),\n      duration: 0.09,\n      type: \"triangle\",\n      gain: 0.018,\n      when: 0.03\n    });\n  }\n\n  playCrashSfx() {\n    this.playTone({ freq: this.noteToHz(42), duration: 0.24, type: \"sawtooth\", gain: 0.03 });\n  }\n\n  dispose() {\n    this.disable();\n  }\n\n  async enable(withToggleChime) {\n    this.ensureContext();\n    if (!this.audioCtx) return;\n\n    if (this.audioCtx.state === \"suspended\") {\n      await this.audioCtx.resume();\n    }\n\n    this.enabled = true;\n    if (this.playbackActive) this.startMusic();\n\n    if (withToggleChime) this.playStartSfx();\n    this.notifyStatus();\n  }\n\n  disable() {\n    this.enabled = false;\n    this.stopMusic();\n    this.notifyStatus();\n  }\n\n  notifyStatus() {\n    this.onStatusChange(this.enabled);\n  }\n\n  ensureContext() {\n    if (this.audioCtx) return;\n\n    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContextCtor) return;\n\n    this.audioCtx = new AudioContextCtor();\n  }\n\n  noteToHz(midi) {\n    return 440 * 2 ** ((midi - 69) / 12);\n  }\n\n  playTone({ freq, duration = 0.1, type = \"square\", gain = 0.04, when = 0 }) {\n    if (!this.enabled || !this.audioCtx) return;\n\n    const startTime = this.audioCtx.currentTime + when;\n    const oscillator = this.audioCtx.createOscillator();\n    const envelope = this.audioCtx.createGain();\n\n    oscillator.type = type;\n    oscillator.frequency.value = freq;\n\n    envelope.gain.setValueAtTime(0.0001, startTime);\n    envelope.gain.exponentialRampToValueAtTime(gain, startTime + 0.01);\n    envelope.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);\n\n    oscillator.connect(envelope);\n    envelope.connect(this.audioCtx.destination);\n\n    oscillator.start(startTime);\n    oscillator.stop(startTime + duration + 0.02);\n  }\n\n  startMusic() {\n    if (!this.enabled || !this.audioCtx || !this.playbackActive || this.musicTimer) return;\n\n    const bass = [40, 40, 43, 45, 40, 40, 47, 45];\n    const lead = [64, 67, 71, 69, 67, 64, 62, 59];\n    const beatMs = Math.max(100, Math.round(260 / this.speedMultiplier));\n\n    this.musicStep = 0;\n    this.musicTimer = setInterval(() => {\n      const index = this.musicStep % bass.length;\n      this.playTone({\n        freq: this.noteToHz(bass[index]),\n        duration: 0.22,\n        type: \"triangle\",\n        gain: 0.015\n      });\n      this.playTone({\n        freq: this.noteToHz(lead[index]),\n        duration: 0.11,\n        type: \"square\",\n        gain: 0.011,\n        when: 0.03\n      });\n      this.musicStep += 1;\n    }, beatMs);\n  }\n\n  stopMusic() {\n    if (!this.musicTimer) return;\n\n    clearInterval(this.musicTimer);\n    this.musicTimer = null;\n  }\n\n  restartMusic() {\n    if (!this.enabled || !this.playbackActive) return;\n    this.stopMusic();\n    this.startMusic();\n  }\n}\n"
  },
  {
    "path": "src/game/constants.js",
    "content": "export const TARGET_SEQUENCE = [\"{\", \"}\", \"(\", \")\", \"[\", \"]\", \";\", \"=\", \"<\", \">\"];\nexport const HAZARD_SEQUENCE = [\n  \":\",\n  \".\",\n  \",\",\n  \"\\\"\",\n  \"'\",\n  \"`\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\"\n];\nexport const KEYWORDS = new Set([\n  \"const\", \"let\", \"var\", \"function\", \"return\", \"if\", \"else\", \"for\", \"while\",\n  \"class\", \"new\", \"true\", \"false\", \"null\", \"undefined\", \"switch\", \"case\",\n  \"break\", \"continue\", \"try\", \"catch\", \"finally\", \"import\", \"from\", \"export\"\n]);\n\nexport const GRID = Object.freeze({\n  width: 72,\n  height: 30\n});\n\nexport const TARGETS = Object.freeze({\n  minChars: 2,\n  maxChars: 4,\n  charGrowthStep: 22,\n  perCharBase: 8,\n  perCharMax: 20,\n  perCharScoreStep: 120,\n  baseQuota: 8,\n  maxQuota: 20,\n  scoreStep: 70\n});\n\nexport const HAZARDS = Object.freeze({\n  unlockAtEaten: 8,\n  baseCount: 4,\n  growthStep: 6,\n  maxCount: 100\n});\n\nexport const SPEED = Object.freeze({\n  baseDelayMs: 180,\n  minDelayMs: 60,\n  maxMultiplier: 2.75,\n  increasePerEat: 0.03\n});\n\nexport const START_DIRECTION = Object.freeze({ x: 1, y: 0 });\n\nexport const UI_TEXT = Object.freeze({\n  ready: \"Press Space to deploy virus.\",\n  fullCorruption: \"System fully corrupted. Press Space to replay.\",\n  fullCorruptionReset: \"System fully corrupted. Press Space to run again.\",\n  crash: \"Virus crashed. Press Space to re-run.\",\n  hazardCrash: \"Virus hit protected code. Press Space to re-run.\"\n});\n"
  },
  {
    "path": "src/game/game-engine.js",
    "content": "import {\n  GRID,\n  HAZARDS,\n  HAZARD_SEQUENCE,\n  KEYWORDS,\n  SPEED,\n  TARGET_SEQUENCE,\n  TARGETS,\n  UI_TEXT\n} from \"./constants.js\";\nimport { createInitialState } from \"./game-state.js\";\nimport {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"./grid.js\";\nimport { buildStyleGrid } from \"./syntax-highlighter.js\";\n\nfunction asSourceProvider(sourceProvider, sourceText) {\n  if (sourceProvider && typeof sourceProvider.nextSource === \"function\") {\n    return sourceProvider;\n  }\n\n  return {\n    nextSource: () => sourceText || \"\"\n  };\n}\n\nexport class GameEngine {\n  constructor({ renderer, audio, sourceProvider, sourceText = \"\" }) {\n    this.renderer = renderer;\n    this.audio = audio;\n    this.sourceProvider = asSourceProvider(sourceProvider, sourceText);\n\n    this.currentSourceText = sourceText;\n    this.codeGrid = [];\n    this.styleGrid = [];\n    this.boardSize = { ...GRID };\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n    this.interval = null;\n  }\n\n  reset() {\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n    this.boardSize = this.computeBoardSize();\n    this.rebuildBoard();\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n\n    this.pickNextTargets();\n    this.refreshHazards();\n    this.syncHud();\n    this.renderer.setMessage(UI_TEXT.ready);\n    this.render();\n  }\n\n  start() {\n    if (this.state.running) return;\n    if (this.state.gameOver) this.reset();\n\n    if (!this.audio.isEnabled()) {\n      void this.audio.ensureEnabledForGameplay();\n    }\n\n    this.state.running = true;\n    this.audio.setPlaybackActive(true);\n    this.audio.setGameSpeed(this.state.speed);\n    this.audio.playStartSfx();\n    this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n  }\n\n  setDirection(x, y) {\n    const tail = this.state.directionQueue.length > 0\n      ? this.state.directionQueue[this.state.directionQueue.length - 1]\n      : this.state.direction;\n\n    if (tail.x === -x && tail.y === -y) return;\n    if (tail.x === x && tail.y === y) return;\n\n    this.state.directionQueue.push({ x, y });\n    if (this.state.directionQueue.length > 2) this.state.directionQueue.shift();\n  }\n\n  toggleAudio() {\n    void this.audio.toggle();\n  }\n\n  dispose() {\n    this.stopLoop();\n    this.audio.dispose();\n  }\n\n  rebuildBoard() {\n    this.currentSourceText = this.sourceProvider.nextSource({\n      width: this.boardSize.width,\n      height: this.boardSize.height\n    });\n\n    this.codeGrid = buildCodeGrid(\n      this.currentSourceText,\n      this.boardSize.width,\n      this.boardSize.height\n    );\n    this.styleGrid = buildStyleGrid(this.codeGrid, KEYWORDS);\n  }\n\n  computeBoardSize() {\n    const measured = this.renderer.measureBoardSize?.();\n    if (\n      measured &&\n      Number.isInteger(measured.width) &&\n      Number.isInteger(measured.height) &&\n      measured.width > 0 &&\n      measured.height > 0\n    ) {\n      return measured;\n    }\n    return { ...GRID };\n  }\n\n  updateLoopSpeed() {\n    const delayMs = Math.max(SPEED.minDelayMs, Math.floor(SPEED.baseDelayMs / this.state.speed));\n    this.stopLoop();\n    this.interval = setInterval(() => this.tick(), delayMs);\n  }\n\n  stopLoop() {\n    if (!this.interval) return;\n    clearInterval(this.interval);\n    this.interval = null;\n  }\n\n  syncHud() {\n    this.renderer.updateStatus({\n      score: this.state.score,\n      targetChar: this.currentTargetLabel(),\n      avoidChars: this.currentAvoidLabel(),\n      eaten: this.state.eatenCount,\n      speed: this.state.speed,\n      audioEnabled: this.audio.isEnabled()\n    });\n  }\n\n  render() {\n    this.renderer.renderBoard({\n      codeGrid: this.codeGrid,\n      styleGrid: this.styleGrid,\n      eaten: this.state.eaten,\n      activeTargets: this.state.activeTargets,\n      hazardCells: this.state.hazardCells,\n      snake: this.state.snake,\n      gameOver: this.state.gameOver,\n      won: this.state.won\n    });\n  }\n\n  tick() {\n    if (!this.state.running || this.state.gameOver) return;\n\n    const queued = this.state.directionQueue.shift();\n    if (queued) this.state.direction = queued;\n\n    const head = this.state.snake[0];\n    const next = {\n      x: head.x + this.state.direction.x,\n      y: head.y + this.state.direction.y\n    };\n\n    if (!inBounds(next.x, next.y, this.boardSize.width, this.boardSize.height)) {\n      this.endGame(false);\n      return;\n    }\n\n    if (this.collidesWithSnake(next.x, next.y)) {\n      this.endGame(false);\n      return;\n    }\n\n    const nextKey = cellKey(next.x, next.y);\n    if (this.state.hazardCells.has(nextKey)) {\n      this.endGame(false, true);\n      return;\n    }\n\n    this.state.snake.unshift(next);\n\n    if (this.state.activeTargets.has(nextKey)) {\n      this.eatTarget(nextKey);\n    } else if (this.state.growth > 0) {\n      this.state.growth -= 1;\n    } else {\n      this.state.snake.pop();\n    }\n\n    if (this.state.gameOver) {\n      this.syncHud();\n      this.render();\n      return;\n    }\n\n    this.refreshHazards();\n    this.syncHud();\n    this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n    this.render();\n  }\n\n  collidesWithSnake(x, y) {\n    for (let i = 0; i < this.state.snake.length; i += 1) {\n      const segment = this.state.snake[i];\n      if (segment.x === x && segment.y === y) return true;\n    }\n    return false;\n  }\n\n  eatTarget(cell) {\n    this.state.activeTargets.delete(cell);\n    this.state.eaten.add(cell);\n    this.state.hazardCells.delete(cell);\n    this.state.eatenCount += 1;\n    this.state.eatenThisTarget += 1;\n    this.state.score += 12 + this.state.snake.length;\n    this.state.growth += 1;\n    this.state.speed = Math.min(\n      SPEED.maxMultiplier,\n      1 + this.state.eatenCount * SPEED.increasePerEat\n    );\n    this.audio.setGameSpeed(this.state.speed);\n\n    this.renderer.triggerGlitch();\n    this.audio.playEatSfx();\n\n    if (this.state.eatenThisTarget >= this.state.targetQuota) {\n      this.pickNextTargets();\n      this.refreshHazards(true);\n      return;\n    }\n\n    this.maybeRefreshTargets();\n  }\n\n  maybeRefreshTargets() {\n    if (this.state.activeTargets.size > 0) return;\n    this.pickNextTargets();\n  }\n\n  pickNextTargets() {\n    const charCount = Math.min(\n      TARGETS.maxChars,\n      TARGETS.minChars + Math.floor(this.state.eatenCount / TARGETS.charGrowthStep)\n    );\n\n    const selected = [];\n    for (let i = 0; i < TARGET_SEQUENCE.length && selected.length < charCount; i += 1) {\n      const idx = (this.state.currentTargetIndex + i) % TARGET_SEQUENCE.length;\n      const char = TARGET_SEQUENCE[idx];\n      const pool = collectTargetCandidates(this.codeGrid, char, this.state.eaten);\n      if (pool.length === 0) continue;\n      selected.push({ idx, char, pool });\n    }\n\n    if (selected.length === 0) {\n      this.state.won = true;\n      this.state.running = false;\n      this.state.gameOver = true;\n      this.stopLoop();\n      this.audio.setPlaybackActive(false);\n      this.renderer.setMessage(UI_TEXT.fullCorruptionReset);\n      return false;\n    }\n\n    const perCharCap = Math.min(\n      TARGETS.perCharMax,\n      TARGETS.perCharBase + Math.floor(this.state.score / TARGETS.perCharScoreStep)\n    );\n\n    const targetCells = new Set();\n    for (const item of selected) {\n      for (const cell of shuffled(item.pool).slice(0, perCharCap)) {\n        targetCells.add(cell);\n      }\n    }\n\n    this.state.activeTargetChars = selected.map((item) => item.char);\n    this.state.currentTargetIndex = (selected[selected.length - 1].idx + 1) % TARGET_SEQUENCE.length;\n    this.state.activeTargets = targetCells;\n    this.state.eatenThisTarget = 0;\n    this.state.targetQuota = Math.min(\n      TARGETS.maxQuota,\n      TARGETS.baseQuota + Math.floor(this.state.score / TARGETS.scoreStep)\n    );\n\n    return true;\n  }\n\n  desiredHazardCount() {\n    if (this.state.eatenCount < HAZARDS.unlockAtEaten) return 0;\n    const growth = Math.floor((this.state.eatenCount - HAZARDS.unlockAtEaten) / HAZARDS.growthStep);\n    return Math.min(HAZARDS.maxCount, HAZARDS.baseCount + growth * 3);\n  }\n\n  refreshHazards(forceReset = false) {\n    const desiredCount = this.desiredHazardCount();\n    if (desiredCount <= 0) {\n      this.state.hazardCells.clear();\n      this.state.activeHazardChars = [];\n      return;\n    }\n\n    if (forceReset) this.state.hazardCells.clear();\n\n    const snakeSet = new Set(this.state.snake.map((segment) => cellKey(segment.x, segment.y)));\n    const byChar = new Map();\n\n    for (const char of HAZARD_SEQUENCE) {\n      const candidates = collectTargetCandidates(this.codeGrid, char, this.state.eaten)\n        .filter((key) => !this.state.activeTargets.has(key))\n        .filter((key) => !snakeSet.has(key));\n\n      if (candidates.length > 0) byChar.set(char, shuffled(candidates));\n    }\n\n    this.state.activeHazardChars = [...byChar.keys()].slice(0, 4);\n\n    const validExisting = new Set();\n    for (const key of this.state.hazardCells) {\n      if (this.state.activeTargets.has(key) || this.state.eaten.has(key) || snakeSet.has(key)) continue;\n      const [x, y] = key.split(\",\").map(Number);\n      if (!inBounds(x, y, this.boardSize.width, this.boardSize.height)) continue;\n      validExisting.add(key);\n    }\n\n    this.state.hazardCells = validExisting;\n\n    const pools = [...byChar.values()];\n    let poolIndex = 0;\n    while (this.state.hazardCells.size < desiredCount && pools.length > 0) {\n      const pool = pools[poolIndex % pools.length];\n      const next = pool.pop();\n      if (next) this.state.hazardCells.add(next);\n      poolIndex += 1;\n\n      if (pool.length === 0) {\n        const idx = pools.indexOf(pool);\n        if (idx >= 0) pools.splice(idx, 1);\n      }\n    }\n  }\n\n  endGame(didWin, hitHazard = false) {\n    this.state.running = false;\n    this.state.gameOver = true;\n    this.state.won = didWin;\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n\n    if (!didWin) this.audio.playCrashSfx();\n\n    const message = didWin\n      ? UI_TEXT.fullCorruption\n      : (hitHazard ? UI_TEXT.hazardCrash : UI_TEXT.crash);\n\n    this.renderer.setMessage(message);\n    this.render();\n  }\n\n  currentTargetLabel() {\n    if (this.state.activeTargetChars.length === 0) {\n      return TARGET_SEQUENCE[this.state.currentTargetIndex] || TARGET_SEQUENCE[0];\n    }\n\n    return this.state.activeTargetChars.join(\" \");\n  }\n\n  currentAvoidLabel() {\n    if (this.state.activeHazardChars.length === 0) return \"-\";\n    return this.state.activeHazardChars.join(\" \");\n  }\n\n  progressMessage() {\n    const target = this.currentTargetLabel();\n    const avoid = this.currentAvoidLabel();\n    return `Corrupt [${target}] (${this.state.eatenThisTarget}/${this.state.targetQuota}). Avoid [${avoid}].`;\n  }\n}\n"
  },
  {
    "path": "src/game/game-state.js",
    "content": "import { START_DIRECTION } from \"./constants.js\";\n\nfunction createInitialSnake(width, height) {\n  const x = Math.floor(width / 2);\n  const y = Math.floor(height / 2);\n\n  return [\n    { x: x - 1, y },\n    { x: x - 2, y },\n    { x: x - 3, y }\n  ];\n}\n\nexport function createInitialState(width, height) {\n  return {\n    eaten: new Set(),\n    snake: createInitialSnake(width, height),\n    direction: { ...START_DIRECTION },\n    queuedDirection: { ...START_DIRECTION },\n    directionQueue: [],\n    score: 0,\n    eatenCount: 0,\n    currentTargetIndex: 0,\n    activeTargetChars: [],\n    targetQuota: 7,\n    eatenThisTarget: 0,\n    activeTargets: new Set(),\n    hazardCells: new Set(),\n    activeHazardChars: [],\n    growth: 0,\n    speed: 1,\n    running: false,\n    gameOver: false,\n    won: false\n  };\n}\n"
  },
  {
    "path": "src/game/grid.js",
    "content": "export function buildCodeGrid(sourceText, width, height) {\n  const lines = sourceText.split(\"\\n\").slice(0, height);\n  return Array.from({ length: height }, (_, y) => {\n    const base = (lines[y] || \"\").padEnd(width, \" \").slice(0, width);\n    return base.split(\"\");\n  });\n}\n\nexport function cellKey(x, y) {\n  return `${x},${y}`;\n}\n\nexport function inBounds(x, y, width, height) {\n  return x >= 0 && x < width && y >= 0 && y < height;\n}\n\nexport function shuffled(values) {\n  const copy = values.slice();\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n}\n\nexport function collectTargetCandidates(codeGrid, char, eatenSet) {\n  const candidates = [];\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const key = cellKey(x, y);\n      if (eatenSet.has(key)) continue;\n      if (codeGrid[y][x] === char) candidates.push(key);\n    }\n  }\n\n  return candidates;\n}\n"
  },
  {
    "path": "src/game/input-controller.js",
    "content": "export function bindInput({ onDirection, onStart, onToggleAudio }) {\n  const handler = (event) => {\n    const key = event.key.toLowerCase();\n\n    if (key === \"arrowup\" || key === \"w\") {\n      event.preventDefault();\n      onDirection(0, -1);\n    }\n\n    if (key === \"arrowdown\" || key === \"s\") {\n      event.preventDefault();\n      onDirection(0, 1);\n    }\n\n    if (key === \"arrowleft\" || key === \"a\") {\n      event.preventDefault();\n      onDirection(-1, 0);\n    }\n\n    if (key === \"arrowright\" || key === \"d\") {\n      event.preventDefault();\n      onDirection(1, 0);\n    }\n\n    if (key === \" \" || key === \"enter\") {\n      event.preventDefault();\n      onStart();\n    }\n\n    if (key === \"m\") {\n      event.preventDefault();\n      onToggleAudio();\n    }\n  };\n\n  document.addEventListener(\"keydown\", handler);\n\n  return () => {\n    document.removeEventListener(\"keydown\", handler);\n  };\n}\n"
  },
  {
    "path": "src/game/renderer.js",
    "content": "import { cellKey } from \"./grid.js\";\n\nfunction cellContent(char) {\n  if (char === \" \") return \"&nbsp;\";\n  if (char === \"<\") return \"&lt;\";\n  if (char === \">\") return \"&gt;\";\n  if (char === \"&\") return \"&amp;\";\n  return char;\n}\n\nexport class Renderer {\n  constructor(elements) {\n    this.elements = elements;\n  }\n\n  measureBoardSize() {\n    const editor = this.elements.editor;\n    if (!editor) return null;\n\n    const computed = getComputedStyle(editor);\n    const paddingX = Number.parseFloat(computed.paddingLeft) + Number.parseFloat(computed.paddingRight);\n    const paddingY = Number.parseFloat(computed.paddingTop) + Number.parseFloat(computed.paddingBottom);\n\n    const probe = document.createElement(\"span\");\n    probe.className = \"cell\";\n    probe.style.position = \"absolute\";\n    probe.style.visibility = \"hidden\";\n    probe.style.pointerEvents = \"none\";\n    probe.textContent = \"M\";\n    editor.appendChild(probe);\n    const charRect = probe.getBoundingClientRect();\n    editor.removeChild(probe);\n\n    const charWidth = Math.max(1, Math.ceil(charRect.width));\n    const lineHeight = Math.max(\n      1,\n      Math.ceil(Number.parseFloat(computed.lineHeight) || charRect.height)\n    );\n\n    const gutterWidth = 42;\n    const usableWidth = Math.max(0, editor.clientWidth - paddingX - gutterWidth);\n    const usableHeight = Math.max(0, editor.clientHeight - paddingY);\n\n    return {\n      width: Math.max(24, Math.floor(usableWidth / charWidth)),\n      height: Math.max(12, Math.floor(usableHeight / lineHeight))\n    };\n  }\n\n  updateStatus({ score, targetChar, avoidChars, eaten, speed, audioEnabled }) {\n    this.elements.score.textContent = String(score);\n    this.elements.targetChar.textContent = targetChar;\n    this.elements.avoidChars.textContent = avoidChars;\n    this.elements.eaten.textContent = String(eaten);\n    this.elements.speed.textContent = `${speed.toFixed(1)}x`;\n    this.updateAudioStatus(audioEnabled);\n  }\n\n  updateAudioStatus(enabled) {\n    this.elements.audioStatus.textContent = enabled ? \"ON\" : \"OFF\";\n  }\n\n  setMessage(message) {\n    this.elements.message.textContent = message;\n  }\n\n  triggerGlitch() {\n    this.elements.app.classList.remove(\"glitch\");\n    void this.elements.app.offsetWidth;\n    this.elements.app.classList.add(\"glitch\");\n    setTimeout(() => this.elements.app.classList.remove(\"glitch\"), 130);\n  }\n\n  renderBoard({\n    codeGrid,\n    styleGrid,\n    eaten,\n    activeTargets,\n    hazardCells,\n    snake,\n    gameOver,\n    won\n  }) {\n    const snakeSet = new Set(snake.map((segment) => cellKey(segment.x, segment.y)));\n    const headKey = snake[0] ? cellKey(snake[0].x, snake[0].y) : \"\";\n\n    const html = [];\n    for (let y = 0; y < codeGrid.length; y += 1) {\n      html.push(`<span class=\"line\"><span class=\"ln\">${String(y + 1).padStart(2, \"0\")}</span>`);\n\n      for (let x = 0; x < codeGrid[y].length; x += 1) {\n        const key = cellKey(x, y);\n        let char = codeGrid[y][x];\n        let className = `cell ${styleGrid[y][x]}`;\n\n        if (eaten.has(key)) {\n          char = \" \";\n          className += \" hole\";\n        } else if (hazardCells.has(key)) {\n          className += \" hazard\";\n        } else if (activeTargets.has(key)) {\n          className += \" target\";\n        }\n\n        if (snakeSet.has(key)) className += \" virus\";\n        if (key === headKey) className += \" head\";\n        if (gameOver && !won && key === headKey) className += \" dead\";\n\n        html.push(`<span class=\"${className}\">${cellContent(char)}</span>`);\n      }\n\n      html.push(\"</span>\");\n    }\n\n    this.elements.editor.innerHTML = html.join(\"\");\n  }\n}\n"
  },
  {
    "path": "src/game/source-text.js",
    "content": "import { HAZARD_SEQUENCE, TARGET_SEQUENCE } from \"./constants.js\";\nimport { SOURCE_CORPUS } from \"./source-corpus.js\";\n\nconst INTEREST_CHARS = new Set([...TARGET_SEQUENCE, ...HAZARD_SEQUENCE]);\n\nfunction scoreContent(content) {\n  let score = 0;\n  for (let i = 0; i < content.length; i += 1) {\n    if (INTEREST_CHARS.has(content[i])) score += 1;\n  }\n  return score;\n}\n\nfunction normalizeCorpus(corpus) {\n  return corpus\n    .map((entry) => {\n      const lines = entry.content.split(\"\\n\");\n      return {\n        path: entry.path,\n        lines,\n        interestScore: scoreContent(entry.content)\n      };\n    })\n    .filter((entry) => entry.lines.length > 0);\n}\n\nexport class SourceTextProvider {\n  constructor(corpus = SOURCE_CORPUS) {\n    this.entries = normalizeCorpus(corpus);\n    this.lastPick = null;\n  }\n\n  nextSource({ width, height }) {\n    if (this.entries.length === 0) return \"\";\n\n    const viable = this.entries.filter((entry) => entry.interestScore >= 18);\n    const pool = viable.length > 0 ? viable : this.entries;\n    let index = Math.floor(Math.random() * pool.length);\n\n    if (pool.length > 1 && this.lastPick && pool[index].path === this.lastPick.path) {\n      index = (index + 1 + Math.floor(Math.random() * (pool.length - 1))) % pool.length;\n    }\n\n    const entry = pool[index];\n    const bodyLines = Math.max(1, height - 2);\n    const maxStart = Math.max(0, entry.lines.length - bodyLines);\n    let start = maxStart > 0 ? Math.floor(Math.random() * (maxStart + 1)) : 0;\n\n    if (\n      maxStart > 0 &&\n      this.lastPick &&\n      this.lastPick.path === entry.path &&\n      this.lastPick.start === start\n    ) {\n      start = (start + 1 + Math.floor(Math.random() * maxStart)) % (maxStart + 1);\n    }\n\n    const end = start + bodyLines;\n    const selected = entry.lines.slice(start, end);\n    const header = [\n      `// source: ${entry.path}`,\n      `// region: ${start + 1}-${Math.min(entry.lines.length, end)}`\n    ];\n\n    const clipped = selected.map((line) => line.slice(0, Math.max(8, width)));\n    this.lastPick = { path: entry.path, start };\n    return [...header, ...clipped].join(\"\\n\");\n  }\n}\n\n"
  },
  {
    "path": "src/game/syntax-highlighter.js",
    "content": "function paintRange(styles, start, end, className) {\n  for (let i = start; i < end && i < styles.length; i += 1) styles[i] = className;\n}\n\nexport function buildStyleGrid(codeGrid, keywords) {\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n  const styleGrid = Array.from({ length: height }, () =>\n    Array.from({ length: width }, () => \"ch\")\n  );\n\n  for (let y = 0; y < height; y += 1) {\n    const line = codeGrid[y].join(\"\");\n    const styles = styleGrid[y];\n    let i = 0;\n\n    while (i < width) {\n      const ch = line[i];\n      const next = i + 1 < width ? line[i + 1] : \"\";\n\n      if (ch === \"/\" && next === \"/\") {\n        paintRange(styles, i, width, \"tk-comment\");\n        break;\n      }\n\n      if (ch === \"'\" || ch === '\"' || ch === \"`\") {\n        const quote = ch;\n        let j = i + 1;\n\n        while (j < width) {\n          if (line[j] === \"\\\\\" && j + 1 < width) {\n            j += 2;\n            continue;\n          }\n          if (line[j] === quote) {\n            j += 1;\n            break;\n          }\n          j += 1;\n        }\n\n        paintRange(styles, i, j, \"tk-string\");\n        i = j;\n        continue;\n      }\n\n      if (/[0-9]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[0-9_.]/.test(line[j])) j += 1;\n        paintRange(styles, i, j, \"tk-number\");\n        i = j;\n        continue;\n      }\n\n      if (/[A-Za-z_$]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[A-Za-z0-9_$]/.test(line[j])) j += 1;\n\n        const word = line.slice(i, j);\n        if (keywords.has(word)) {\n          paintRange(styles, i, j, \"tk-keyword\");\n        } else {\n          let lookahead = j;\n          while (lookahead < width && /\\s/.test(line[lookahead])) lookahead += 1;\n          if (lookahead < width && line[lookahead] === \"(\") {\n            paintRange(styles, i, j, \"tk-function\");\n          }\n        }\n\n        i = j;\n        continue;\n      }\n\n      if (\"{}[]();,.<>:+-*/=%!?&|\".includes(ch)) styles[i] = \"tk-punct\";\n      i += 1;\n    }\n  }\n\n  return styleGrid;\n}\n"
  },
  {
    "path": "src/main.js",
    "content": "import { AudioEngine } from \"./game/audio-engine.js\";\nimport { GameEngine } from \"./game/game-engine.js\";\nimport { bindInput } from \"./game/input-controller.js\";\nimport { Renderer } from \"./game/renderer.js\";\nimport { SourceTextProvider } from \"./game/source-text.js\";\n\nfunction requireElement(id) {\n  const element = document.getElementById(id);\n  if (!element) throw new Error(`Missing required element: #${id}`);\n  return element;\n}\n\nconst elements = {\n  app: requireElement(\"app\"),\n  editor: requireElement(\"editor\"),\n  score: requireElement(\"score\"),\n  targetChar: requireElement(\"targetChar\"),\n  avoidChars: requireElement(\"avoidChars\"),\n  eaten: requireElement(\"eaten\"),\n  speed: requireElement(\"speed\"),\n  audioStatus: requireElement(\"audioStatus\"),\n  message: requireElement(\"message\")\n};\n\nconst renderer = new Renderer(elements);\nconst audio = new AudioEngine((enabled) => renderer.updateAudioStatus(enabled));\nconst sourceProvider = new SourceTextProvider();\nconst game = new GameEngine({ renderer, audio, sourceProvider });\n\nconst unbindInput = bindInput({\n  onDirection: (x, y) => game.setDirection(x, y),\n  onStart: () => game.start(),\n  onToggleAudio: () => game.toggleAudio()\n});\n\ngame.reset();\n\nwindow.addEventListener(\"beforeunload\", () => {\n  unbindInput();\n  game.dispose();\n});\n"
  },
  {
    "path": "src/styles/main.css",
    "content": ":root {\n  --bg: #0f141a;\n  --panel: #151d26;\n  --panel-2: #1c2732;\n  --ink: #d6e2f0;\n  --muted: #88a4bf;\n  --accent: #7ef2c5;\n  --danger: #ff7a8a;\n  --line: #243545;\n  --target: #ffd166;\n  --virus: #8bff66;\n  --virus-head: #e6ff96;\n  --tk-keyword: #6ed0ff;\n  --tk-string: #f7a86e;\n  --tk-number: #79e6a4;\n  --tk-comment: #637f99;\n  --tk-function: #d2b7ff;\n  --tk-punct: #9db7d1;\n}\n\n* {\n  box-sizing: border-box;\n}\n\nbody {\n  margin: 0;\n  min-height: 100vh;\n  color: var(--ink);\n  background:\n    radial-gradient(circle at 20% -10%, #25435f 0%, transparent 30%),\n    radial-gradient(circle at 120% 0%, #2e2244 0%, transparent 35%),\n    linear-gradient(180deg, #0b1015 0%, var(--bg) 65%);\n  font-family: \"JetBrains Mono\", \"IBM Plex Mono\", \"Fira Code\", monospace;\n  display: grid;\n  place-items: center;\n  padding: 18px;\n}\n\n.app {\n  width: min(1140px, 100%);\n  border: 1px solid #27394b;\n  border-radius: 14px;\n  overflow: hidden;\n  background: linear-gradient(180deg, #101821 0%, #0f151d 100%);\n  box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);\n}\n\n.titlebar {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  background: #0d1319;\n  border-bottom: 1px solid var(--line);\n  padding: 10px 14px;\n  font-size: 13px;\n}\n\n.lights {\n  display: flex;\n  gap: 7px;\n}\n\n.light {\n  width: 10px;\n  height: 10px;\n  border-radius: 50%;\n}\n\n.light.r {\n  background: #ff5f57;\n}\n\n.light.y {\n  background: #ffbd2e;\n}\n\n.light.g {\n  background: #27c93f;\n}\n\n.workspace {\n  display: grid;\n  grid-template-columns: 230px 1fr;\n  min-height: min(760px, calc(100vh - 70px));\n}\n\n.hud {\n  background: var(--panel);\n  border-right: 1px solid var(--line);\n  padding: 16px;\n  display: flex;\n  flex-direction: column;\n  gap: 14px;\n}\n\n.hud h1 {\n  margin: 0;\n  font-size: 16px;\n  line-height: 1.2;\n  letter-spacing: 0.4px;\n}\n\n.status {\n  display: grid;\n  gap: 8px;\n}\n\n.item {\n  background: var(--panel-2);\n  border: 1px solid #2a3d4f;\n  border-radius: 10px;\n  padding: 10px;\n}\n\n.k {\n  color: var(--muted);\n  font-size: 12px;\n}\n\n.v {\n  font-size: 18px;\n  color: var(--accent);\n  margin-top: 2px;\n}\n\n#targetChar,\n#avoidChars {\n  font-size: 15px;\n  letter-spacing: 0.3px;\n  word-spacing: 3px;\n}\n\n.help {\n  font-size: 12px;\n  line-height: 1.45;\n  color: #aec3d8;\n}\n\n.cta {\n  margin-top: auto;\n  border: 1px dashed #355068;\n  border-radius: 10px;\n  background: #14202a;\n  color: #b5d0e7;\n  font-size: 12px;\n  padding: 10px;\n}\n\n.editor-wrap {\n  position: relative;\n  background: #0e151d;\n  overflow: hidden;\n}\n\n.editor-head {\n  display: flex;\n  gap: 14px;\n  align-items: center;\n  font-size: 12px;\n  color: #87a6c3;\n  border-bottom: 1px solid var(--line);\n  padding: 9px 12px;\n  background: #121b25;\n}\n\n#editor {\n  margin: 0;\n  padding: 14px 12px 20px 12px;\n  font-size: 14px;\n  line-height: 1.2;\n  white-space: pre;\n  overflow: auto;\n  height: calc(100% - 37px);\n}\n\n.line {\n  display: block;\n}\n\n.ln {\n  display: inline-block;\n  width: 42px;\n  color: #4f6c87;\n  user-select: none;\n}\n\n.ch {\n  color: #cad8e8;\n}\n\n.cell {\n  display: inline-block;\n}\n\n.hole {\n  background: transparent;\n  color: transparent;\n}\n\n.target {\n  color: var(--target) !important;\n  background: rgba(255, 209, 102, 0.28);\n  box-shadow:\n    inset 0 0 0 1px rgba(255, 222, 133, 0.85),\n    0 0 12px rgba(255, 209, 102, 0.4);\n  text-shadow:\n    0 0 10px rgba(255, 209, 102, 0.65),\n    0 0 2px rgba(255, 247, 211, 0.95);\n  font-weight: 700;\n  border-radius: 2px;\n  animation: target-pulse 1.2s ease-in-out infinite;\n}\n\n.hazard {\n  color: #ff91a0 !important;\n  background: rgba(255, 122, 138, 0.18);\n  box-shadow:\n    inset 0 0 0 1px rgba(255, 145, 160, 0.6),\n    0 0 10px rgba(255, 122, 138, 0.25);\n  text-shadow: 0 0 8px rgba(255, 122, 138, 0.6);\n  border-radius: 2px;\n}\n\n.tk-keyword {\n  color: var(--tk-keyword);\n}\n\n.tk-string {\n  color: var(--tk-string);\n}\n\n.tk-number {\n  color: var(--tk-number);\n}\n\n.tk-comment {\n  color: var(--tk-comment);\n}\n\n.tk-function {\n  color: var(--tk-function);\n}\n\n.tk-punct {\n  color: var(--tk-punct);\n}\n\n.virus {\n  background: rgba(89, 255, 83, 0.2);\n  color: var(--virus);\n}\n\n.head {\n  background: rgba(205, 255, 97, 0.28);\n  color: var(--virus-head);\n}\n\n.dead {\n  color: var(--danger);\n}\n\n.glitch #editor {\n  animation: jitter 140ms steps(3);\n}\n\n@keyframes jitter {\n  0% {\n    transform: translate(0, 0);\n    filter: hue-rotate(0deg);\n  }\n\n  25% {\n    transform: translate(-3px, 1px);\n    filter: hue-rotate(40deg);\n  }\n\n  50% {\n    transform: translate(3px, -1px);\n    filter: hue-rotate(-40deg);\n  }\n\n  100% {\n    transform: translate(0, 0);\n    filter: hue-rotate(0deg);\n  }\n}\n\n@keyframes target-pulse {\n  0% {\n    filter: brightness(1);\n  }\n\n  50% {\n    filter: brightness(1.25);\n  }\n\n  100% {\n    filter: brightness(1);\n  }\n}\n\n@media (max-width: 900px) {\n  .workspace {\n    grid-template-columns: 1fr;\n    grid-template-rows: auto 1fr;\n  }\n\n  .hud {\n    border-right: 0;\n    border-bottom: 1px solid var(--line);\n  }\n}\n"
  },
  {
    "path": "tests/game-engine.test.js",
    "content": "import { jest } from \"@jest/globals\";\nimport { HAZARDS, UI_TEXT } from \"../src/game/constants.js\";\nimport { GameEngine } from \"../src/game/game-engine.js\";\nimport { cellKey } from \"../src/game/grid.js\";\n\nfunction buildSource(lines = 30) {\n  const row = \"{ } ( ) [ ] ; = < > function run() { return 42; } // comment\";\n  return Array.from({ length: lines }, () => row).join(\"\\n\");\n}\n\nfunction createRendererMock({ measuredBoardSize = null } = {}) {\n  return {\n    updateStatus: jest.fn(),\n    updateAudioStatus: jest.fn(),\n    setMessage: jest.fn(),\n    renderBoard: jest.fn(),\n    triggerGlitch: jest.fn(),\n    measureBoardSize: jest.fn(() => measuredBoardSize)\n  };\n}\n\nfunction createAudioMock({ enabled = true } = {}) {\n  return {\n    isEnabled: jest.fn(() => enabled),\n    ensureEnabledForGameplay: jest.fn(() => Promise.resolve()),\n    toggle: jest.fn(() => Promise.resolve()),\n    setPlaybackActive: jest.fn(),\n    setGameSpeed: jest.fn(),\n    dispose: jest.fn(),\n    playStartSfx: jest.fn(),\n    playEatSfx: jest.fn(),\n    playCrashSfx: jest.fn()\n  };\n}\n\nfunction createEngine(options = {}) {\n  const renderer = createRendererMock({\n    measuredBoardSize: options.measuredBoardSize ?? null\n  });\n  const audio = createAudioMock({ enabled: options.audioEnabled ?? true });\n  const engine = new GameEngine({\n    renderer,\n    audio,\n    sourceProvider: options.sourceProvider,\n    sourceText: options.sourceText ?? buildSource()\n  });\n\n  return { engine, renderer, audio };\n}\n\ndescribe(\"GameEngine\", () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  test(\"reset initializes board, HUD, and ready message\", () => {\n    const { engine, renderer } = createEngine();\n\n    engine.reset();\n\n    expect(engine.state.running).toBe(false);\n    expect(engine.state.gameOver).toBe(false);\n    expect(engine.state.activeTargets.size).toBeGreaterThan(0);\n\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.ready);\n    expect(renderer.updateStatus).toHaveBeenCalled();\n    expect(renderer.renderBoard).toHaveBeenCalled();\n\n    const lastHud = renderer.updateStatus.mock.calls.at(-1)[0];\n    expect(lastHud.targetChar.length).toBeGreaterThan(0);\n    expect(lastHud.targetChar).toContain(\"{\");\n  });\n\n  test(\"reset uses renderer-measured board size when available\", () => {\n    const { engine } = createEngine({ measuredBoardSize: { width: 40, height: 18 } });\n\n    engine.reset();\n\n    expect(engine.boardSize).toEqual({ width: 40, height: 18 });\n    expect(engine.codeGrid.length).toBe(18);\n    expect(engine.codeGrid[0].length).toBe(40);\n  });\n\n  test(\"uses custom source provider when supplied\", () => {\n    const sourceProvider = { nextSource: jest.fn(() => \"{ provider-source }\") };\n    const { engine } = createEngine({ sourceProvider });\n\n    engine.reset();\n\n    expect(sourceProvider.nextSource).toHaveBeenCalled();\n    expect(engine.currentSourceText).toContain(\"provider-source\");\n  });\n\n  test(\"start begins loop and triggers start SFX\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.start();\n\n    expect(engine.state.running).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(true);\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(audio.playStartSfx).toHaveBeenCalledTimes(1);\n    expect(jest.getTimerCount()).toBeGreaterThan(0);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toMatch(/^Corrupt/);\n  });\n\n  test(\"stopLoop clears the active loop interval\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n    engine.start();\n    expect(engine.interval).not.toBeNull();\n\n    engine.stopLoop();\n    expect(engine.interval).toBeNull();\n  });\n\n  test(\"start asks audio engine to enable when currently disabled\", () => {\n    const { engine, audio } = createEngine({ audioEnabled: false });\n    engine.reset();\n\n    engine.start();\n\n    expect(audio.ensureEnabledForGameplay).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"setDirection queues rapid turns and blocks reversals\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([]);\n\n    engine.setDirection(0, -1);\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n\n    engine.setDirection(1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n  });\n\n  test(\"tick ends the game on wall collision\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 0, y: 0 }];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.crash);\n  });\n\n  test(\"tick ends the game on self-collision\", () => {\n    const { engine, audio } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [\n      { x: 2, y: 2 },\n      { x: 3, y: 2 },\n      { x: 3, y: 3 },\n      { x: 2, y: 3 }\n    ];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"tick consumes target cells and updates progression state\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n\n    const oldScore = engine.state.score;\n    const oldLength = engine.state.snake.length;\n\n    engine.tick();\n\n    expect(engine.state.eaten.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.eatenCount).toBe(1);\n    expect(engine.state.eatenThisTarget).toBeGreaterThanOrEqual(0);\n    expect(engine.state.score).toBeGreaterThan(oldScore);\n    expect(engine.state.speed).toBeGreaterThan(1);\n    expect(engine.state.snake.length).toBe(oldLength + 1);\n\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(renderer.triggerGlitch).toHaveBeenCalledTimes(1);\n    expect(audio.playEatSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"tick decrements growth on empty movement and keeps tail length\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 1;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.growth).toBe(0);\n    expect(engine.state.snake.length).toBe(beforeLength + 1);\n  });\n\n  test(\"tick pops tail on empty movement when no growth remains\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 0;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.snake.length).toBe(beforeLength);\n  });\n\n  test(\"consuming the final quota target rotates to the next target set\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n    engine.state.targetQuota = 1;\n    engine.state.eatenThisTarget = 0;\n    const previousTarget = engine.state.currentTargetIndex;\n\n    engine.tick();\n\n    expect(engine.state.currentTargetIndex).not.toBe(previousTarget);\n    expect(engine.state.eatenThisTarget).toBe(0);\n  });\n\n  test(\"pickNextTargets reports full corruption when no targets remain\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.eaten.add(\"0,0\");\n    engine.state.activeTargets.clear();\n\n    const found = engine.pickNextTargets();\n\n    expect(found).toBe(false);\n    expect(engine.state.gameOver).toBe(true);\n    expect(engine.state.won).toBe(true);\n    expect(engine.audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"hazard collision ends game with hazard-specific message\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 2, y: 2 }];\n    engine.state.hazardCells = new Set([cellKey(3, 2)]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.hazardCrash);\n  });\n\n  test(\"refreshHazards creates avoid cells as progression increases\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = HAZARDS.unlockAtEaten + HAZARDS.growthStep * 2;\n    engine.state.activeTargets = new Set();\n    engine.state.hazardCells = new Set([\"0,0\"]);\n    engine.state.snake = [{ x: 10, y: 10 }];\n\n    engine.refreshHazards(true);\n\n    expect(engine.state.activeHazardChars.length).toBeGreaterThan(0);\n    expect(engine.state.hazardCells.size).toBeGreaterThan(0);\n  });\n\n  test(\"refreshHazards clears existing hazards when below unlock threshold\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = 0;\n    engine.state.hazardCells = new Set([\"1,1\", \"2,2\"]);\n    engine.state.activeHazardChars = [\":\", \".\"];\n\n    engine.refreshHazards();\n\n    expect(engine.state.hazardCells.size).toBe(0);\n    expect(engine.state.activeHazardChars).toEqual([]);\n  });\n\n  test(\"label helpers handle empty and populated states\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.activeTargetChars = [];\n    engine.state.currentTargetIndex = 0;\n    expect(engine.currentTargetLabel()).toBe(\"{\");\n\n    engine.state.activeHazardChars = [];\n    expect(engine.currentAvoidLabel()).toBe(\"-\");\n\n    engine.state.activeTargetChars = [\"{\", \"}\", \";\"];\n    engine.state.activeHazardChars = [\":\", \".\"];\n    expect(engine.currentTargetLabel()).toBe(\"{ } ;\");\n    expect(engine.currentAvoidLabel()).toBe(\": .\");\n  });\n\n  test(\"tick keeps full-corruption message when terminal state happens mid-tick\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 0 }];\n    engine.state.activeTargets = new Set([\"0,0\"]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toBe(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"toggleAudio and dispose delegate to audio engine\", () => {\n    const { engine, audio } = createEngine();\n\n    engine.toggleAudio();\n    engine.dispose();\n\n    expect(audio.toggle).toHaveBeenCalledTimes(1);\n    expect(audio.dispose).toHaveBeenCalledTimes(1);\n  });\n});\n"
  },
  {
    "path": "tests/game-state.test.js",
    "content": "import { START_DIRECTION } from \"../src/game/constants.js\";\nimport { createInitialState } from \"../src/game/game-state.js\";\n\ndescribe(\"createInitialState\", () => {\n  test(\"creates expected defaults and centered snake\", () => {\n    const state = createInitialState(20, 10);\n\n    expect(state.score).toBe(0);\n    expect(state.eatenCount).toBe(0);\n    expect(state.speed).toBe(1);\n    expect(state.running).toBe(false);\n    expect(state.gameOver).toBe(false);\n    expect(state.won).toBe(false);\n\n    expect(state.direction).toEqual(START_DIRECTION);\n    expect(state.queuedDirection).toEqual(START_DIRECTION);\n    expect(state.directionQueue).toEqual([]);\n    expect(state.snake).toEqual([\n      { x: 9, y: 5 },\n      { x: 8, y: 5 },\n      { x: 7, y: 5 }\n    ]);\n  });\n\n  test(\"returns fresh mutable collections per call\", () => {\n    const a = createInitialState(20, 10);\n    const b = createInitialState(20, 10);\n\n    a.eaten.add(\"1,1\");\n    a.activeTargets.add(\"2,2\");\n    a.direction.x = 999;\n\n    expect(b.eaten.size).toBe(0);\n    expect(b.activeTargets.size).toBe(0);\n    expect(b.direction).toEqual(START_DIRECTION);\n  });\n});\n"
  },
  {
    "path": "tests/grid.test.js",
    "content": "import {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"../src/game/grid.js\";\n\ndescribe(\"grid utilities\", () => {\n  test(\"buildCodeGrid pads and truncates lines to requested dimensions\", () => {\n    const grid = buildCodeGrid(\"abc\\nlonger-than-width\\n\", 5, 3);\n\n    expect(grid).toEqual([\n      [\"a\", \"b\", \"c\", \" \", \" \"],\n      [\"l\", \"o\", \"n\", \"g\", \"e\"],\n      [\" \", \" \", \" \", \" \", \" \"]\n    ]);\n  });\n\n  test(\"cellKey creates stable key strings\", () => {\n    expect(cellKey(10, 4)).toBe(\"10,4\");\n  });\n\n  test(\"inBounds checks coordinates correctly\", () => {\n    expect(inBounds(0, 0, 3, 3)).toBe(true);\n    expect(inBounds(2, 2, 3, 3)).toBe(true);\n    expect(inBounds(-1, 0, 3, 3)).toBe(false);\n    expect(inBounds(0, 3, 3, 3)).toBe(false);\n    expect(inBounds(3, 0, 3, 3)).toBe(false);\n  });\n\n  test(\"shuffled returns a new array with same values\", () => {\n    const input = [\"a\", \"b\", \"c\", \"d\"];\n    const result = shuffled(input);\n\n    expect(result).not.toBe(input);\n    expect(result.slice().sort()).toEqual(input.slice().sort());\n  });\n\n  test(\"collectTargetCandidates returns only non-eaten matches\", () => {\n    const grid = [\n      [\"{\", \"x\", \"{\"],\n      [\"}\", \"{\", \"y\"]\n    ];\n    const eaten = new Set([\"2,0\"]);\n\n    expect(collectTargetCandidates(grid, \"{\", eaten).sort()).toEqual([\"0,0\", \"1,1\"]);\n    expect(collectTargetCandidates(grid, \"}\", eaten)).toEqual([\"0,1\"]);\n  });\n});\n"
  },
  {
    "path": "tests/source-text.test.js",
    "content": "import { SourceTextProvider } from \"../src/game/source-text.js\";\n\ndescribe(\"SourceTextProvider\", () => {\n  test(\"returns source text windows with metadata header\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"one\\ntwo\\nthree\\nfour\" }\n    ]);\n\n    const snippet = provider.nextSource({ width: 80, height: 4 });\n    const lines = snippet.split(\"\\n\");\n\n    expect(lines[0]).toMatch(/^\\/\\/ source: a\\.js/);\n    expect(lines[1]).toMatch(/^\\/\\/ region: /);\n    expect(lines.length).toBe(4);\n  });\n\n  test(\"avoids repeating identical pick when multiple corpus entries exist\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"alpha\\nbeta\\ngamma\" },\n      { path: \"b.js\", content: \"delta\\nepsilon\\nzeta\" }\n    ]);\n\n    const first = provider.nextSource({ width: 80, height: 4 });\n    const second = provider.nextSource({ width: 80, height: 4 });\n\n    expect(first).not.toBe(second);\n  });\n});\n"
  },
  {
    "path": "tests/syntax-highlighter.test.js",
    "content": "import { KEYWORDS } from \"../src/game/constants.js\";\nimport { buildStyleGrid } from \"../src/game/syntax-highlighter.js\";\n\nfunction lineToGrid(line) {\n  return [line.split(\"\")];\n}\n\ndescribe(\"buildStyleGrid\", () => {\n  test(\"highlights keywords and function identifiers\", () => {\n    const line = \"const run = move();\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles.slice(0, 5).every((s) => s === \"tk-keyword\")).toBe(true);\n    expect(styles[line.indexOf(\"move\")]).toBe(\"tk-function\");\n  });\n\n  test(\"highlights strings and numbers\", () => {\n    const line = \"let value = \\\"hi\\\" + 10_5;\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"let\")]).toBe(\"tk-keyword\");\n    expect(styles[line.indexOf('\"')]).toBe(\"tk-string\");\n    expect(styles[line.indexOf(\"1\")]).toBe(\"tk-number\");\n  });\n\n  test(\"highlights comments until line end\", () => {\n    const line = \"x = 2; // todo\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n    const commentStart = line.indexOf(\"//\");\n\n    expect(styles[commentStart]).toBe(\"tk-comment\");\n    expect(styles.slice(commentStart).every((s) => s === \"tk-comment\")).toBe(true);\n  });\n\n  test(\"marks punctuation tokens\", () => {\n    const line = \"{ a: (b + c) }\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"{\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\":\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\"+\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\")\")]).toBe(\"tk-punct\");\n  });\n});\n"
  }
];
