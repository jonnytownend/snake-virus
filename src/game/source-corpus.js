// Auto-generated by scripts/generate-source-corpus.mjs
// Do not edit manually.

export const SOURCE_CORPUS = [
  {
    "path": "jest.config.js",
    "content": "export default {\n  testEnvironment: \"node\",\n  watchman: false,\n  roots: [\"<rootDir>/tests\"],\n  testMatch: [\"**/*.test.js\"],\n  collectCoverageFrom: [\n    \"src/game/constants.js\",\n    \"src/game/game-state.js\",\n    \"src/game/grid.js\",\n    \"src/game/syntax-highlighter.js\",\n    \"src/game/game-engine.js\"\n  ],\n  coverageReporters: [\"text\", \"lcov\", \"html\"],\n  coverageThreshold: {\n    global: {\n      statements: 85,\n      branches: 80,\n      functions: 85,\n      lines: 85\n    }\n  }\n};\n"
  },
  {
    "path": "src/game/audio-engine.js",
    "content": "export class AudioEngine {\n  constructor(onStatusChange = () => {}) {\n    this.onStatusChange = onStatusChange;\n    this.enabled = false;\n    this.playbackActive = false;\n    this.speedMultiplier = 1;\n    this.audioCtx = null;\n    this.musicTimer = null;\n    this.musicStep = 0;\n    this.notifyStatus();\n  }\n\n  isEnabled() {\n    return this.enabled;\n  }\n\n  async toggle() {\n    if (this.enabled) {\n      this.disable();\n      return;\n    }\n\n    await this.enable(true);\n  }\n\n  async ensureEnabledForGameplay() {\n    if (this.enabled) return;\n    await this.enable(false);\n  }\n\n  setPlaybackActive(active) {\n    this.playbackActive = active;\n    if (this.playbackActive) {\n      this.startMusic();\n      return;\n    }\n    this.stopMusic();\n  }\n\n  setGameSpeed(multiplier) {\n    this.speedMultiplier = Math.max(1, Number(multiplier) || 1);\n    if (this.musicTimer) this.restartMusic();\n  }\n\n  playStartSfx() {\n    this.playTone({ freq: this.noteToHz(64), duration: 0.06, type: \"square\", gain: 0.02 });\n    this.playTone({\n      freq: this.noteToHz(71),\n      duration: 0.08,\n      type: \"square\",\n      gain: 0.02,\n      when: 0.06\n    });\n  }\n\n  playEatSfx() {\n    this.playTone({ freq: this.noteToHz(76), duration: 0.07, type: \"triangle\", gain: 0.025 });\n    this.playTone({\n      freq: this.noteToHz(83),\n      duration: 0.09,\n      type: \"triangle\",\n      gain: 0.018,\n      when: 0.03\n    });\n  }\n\n  playCrashSfx() {\n    this.playTone({ freq: this.noteToHz(42), duration: 0.24, type: \"sawtooth\", gain: 0.03 });\n  }\n\n  dispose() {\n    this.disable();\n  }\n\n  async enable(withToggleChime) {\n    this.ensureContext();\n    if (!this.audioCtx) return;\n\n    if (this.audioCtx.state === \"suspended\") {\n      await this.audioCtx.resume();\n    }\n\n    this.enabled = true;\n    if (this.playbackActive) this.startMusic();\n\n    if (withToggleChime) this.playStartSfx();\n    this.notifyStatus();\n  }\n\n  disable() {\n    this.enabled = false;\n    this.stopMusic();\n    this.notifyStatus();\n  }\n\n  notifyStatus() {\n    this.onStatusChange(this.enabled);\n  }\n\n  ensureContext() {\n    if (this.audioCtx) return;\n\n    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;\n    if (!AudioContextCtor) return;\n\n    this.audioCtx = new AudioContextCtor();\n  }\n\n  noteToHz(midi) {\n    return 440 * 2 ** ((midi - 69) / 12);\n  }\n\n  playTone({ freq, duration = 0.1, type = \"square\", gain = 0.04, when = 0 }) {\n    if (!this.enabled || !this.audioCtx) return;\n\n    const startTime = this.audioCtx.currentTime + when;\n    const oscillator = this.audioCtx.createOscillator();\n    const envelope = this.audioCtx.createGain();\n\n    oscillator.type = type;\n    oscillator.frequency.value = freq;\n\n    envelope.gain.setValueAtTime(0.0001, startTime);\n    envelope.gain.exponentialRampToValueAtTime(gain, startTime + 0.01);\n    envelope.gain.exponentialRampToValueAtTime(0.0001, startTime + duration);\n\n    oscillator.connect(envelope);\n    envelope.connect(this.audioCtx.destination);\n\n    oscillator.start(startTime);\n    oscillator.stop(startTime + duration + 0.02);\n  }\n\n  startMusic() {\n    if (!this.enabled || !this.audioCtx || !this.playbackActive || this.musicTimer) return;\n\n    const bass = [40, 40, 43, 45, 40, 40, 47, 45];\n    const lead = [64, 67, 71, 69, 67, 64, 62, 59];\n    const beatMs = Math.max(100, Math.round(260 / this.speedMultiplier));\n\n    this.musicStep = 0;\n    this.musicTimer = setInterval(() => {\n      const index = this.musicStep % bass.length;\n      this.playTone({\n        freq: this.noteToHz(bass[index]),\n        duration: 0.22,\n        type: \"triangle\",\n        gain: 0.015\n      });\n      this.playTone({\n        freq: this.noteToHz(lead[index]),\n        duration: 0.11,\n        type: \"square\",\n        gain: 0.011,\n        when: 0.03\n      });\n      this.musicStep += 1;\n    }, beatMs);\n  }\n\n  stopMusic() {\n    if (!this.musicTimer) return;\n\n    clearInterval(this.musicTimer);\n    this.musicTimer = null;\n  }\n\n  restartMusic() {\n    if (!this.enabled || !this.playbackActive) return;\n    this.stopMusic();\n    this.startMusic();\n  }\n}\n"
  },
  {
    "path": "src/game/constants.js",
    "content": "export const TARGET_SEQUENCE = [\n  \"{\",\n  \"}\",\n  \"(\",\n  \")\",\n  \"[\",\n  \"]\",\n  \";\",\n  \"=\",\n  \"<\",\n  \">\",\n  \"a\",\n  \"e\",\n  \"i\",\n  \"o\",\n  \"u\",\n  \"s\",\n  \"r\",\n  \"t\",\n  \"n\",\n  \"l\",\n  \"c\",\n  \"d\",\n  \"m\",\n  \"f\"\n];\nexport const HAZARD_SEQUENCE = [\n  \":\",\n  \".\",\n  \",\",\n  \"\\\"\",\n  \"'\",\n  \"`\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\"\n];\n\nexport const CORRUPTION_CHARS = [\n  \"#\",\n  \"@\",\n  \"%\",\n  \"&\",\n  \"*\",\n  \"?\",\n  \"!\",\n  \"+\",\n  \"=\",\n  \"~\",\n  \"$\",\n  \"^\",\n  \"/\",\n  \"\\\\\",\n  \"|\",\n  \"<\",\n  \">\",\n  \"_\"\n];\nexport const KEYWORDS = new Set([\n  \"const\", \"let\", \"var\", \"function\", \"return\", \"if\", \"else\", \"for\", \"while\",\n  \"class\", \"new\", \"true\", \"false\", \"null\", \"undefined\", \"switch\", \"case\",\n  \"break\", \"continue\", \"try\", \"catch\", \"finally\", \"import\", \"from\", \"export\"\n]);\n\nexport const GRID = Object.freeze({\n  width: 72,\n  height: 30\n});\n\nexport const TARGETS = Object.freeze({\n  minChars: 2,\n  maxChars: 4,\n  charGrowthStep: 22,\n  perCharBase: 8,\n  perCharMax: 20,\n  perCharScoreStep: 120,\n  baseQuota: 8,\n  maxQuota: 20,\n  scoreStep: 70\n});\n\nexport const HAZARDS = Object.freeze({\n  unlockAtEaten: 8,\n  baseCount: 4,\n  growthStep: 6,\n  maxCount: 100\n});\n\nexport const SPEED = Object.freeze({\n  baseDelayMs: 180,\n  minDelayMs: 60,\n  maxMultiplier: 2.75,\n  increasePerEat: 0.03\n});\n\nexport const STAGES = Object.freeze({\n  corruptionsPerLevel: 10\n});\n\nexport const START_DIRECTION = Object.freeze({ x: 1, y: 0 });\n\nexport const UI_TEXT = Object.freeze({\n  ready: \"Press Space to unleash Snake Virus.\",\n  fullCorruption: \"System fully corrupted. Press Space to replay.\",\n  fullCorruptionReset: \"System fully corrupted. Press Space to run again.\",\n  crash: \"Virus crashed. Press Space to re-run.\",\n  hazardCrash: \"Virus hit protected code. Press Space to re-run.\",\n  corruptionCrash: \"Virus consumed corrupted code. Press Space to re-run.\"\n});\n"
  },
  {
    "path": "src/game/game-engine.js",
    "content": "import {\n  CORRUPTION_CHARS,\n  GRID,\n  HAZARDS,\n  HAZARD_SEQUENCE,\n  KEYWORDS,\n  SPEED,\n  STAGES,\n  TARGET_SEQUENCE,\n  TARGETS,\n  UI_TEXT\n} from \"./constants.js\";\nimport { createInitialState } from \"./game-state.js\";\nimport {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"./grid.js\";\nimport { buildStyleGrid } from \"./syntax-highlighter.js\";\n\nfunction asSourceProvider(sourceProvider, sourceText) {\n  if (sourceProvider && typeof sourceProvider.nextSource === \"function\") {\n    return sourceProvider;\n  }\n\n  return {\n    nextSource: () => sourceText || \"\"\n  };\n}\n\nexport class GameEngine {\n  constructor({ renderer, audio, sourceProvider, sourceText = \"\" }) {\n    this.renderer = renderer;\n    this.audio = audio;\n    this.sourceProvider = asSourceProvider(sourceProvider, sourceText);\n\n    this.currentSourceText = sourceText;\n    this.currentSourcePath = \"unknown.js\";\n    this.codeGrid = [];\n    this.styleGrid = [];\n    this.boardSize = { ...GRID };\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n    this.interval = null;\n  }\n\n  reset() {\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n    this.boardSize = this.computeBoardSize();\n    this.rebuildBoard();\n    this.state = createInitialState(this.boardSize.width, this.boardSize.height);\n\n    this.pickNextTargets();\n    this.refreshHazards();\n    this.syncHud();\n    this.renderer.setMessage(UI_TEXT.ready);\n    this.render();\n  }\n\n  start() {\n    if (this.state.running) return;\n    if (this.state.gameOver) this.reset();\n\n    if (!this.audio.isEnabled()) {\n      void this.audio.ensureEnabledForGameplay();\n    }\n\n    this.state.running = true;\n    this.audio.setPlaybackActive(true);\n    this.audio.setGameSpeed(this.state.speed);\n    this.audio.playStartSfx();\n    this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n  }\n\n  setDirection(x, y) {\n    const tail = this.state.directionQueue.length > 0\n      ? this.state.directionQueue[this.state.directionQueue.length - 1]\n      : this.state.direction;\n\n    if (tail.x === -x && tail.y === -y) return;\n    if (tail.x === x && tail.y === y) return;\n\n    this.state.directionQueue.push({ x, y });\n    if (this.state.directionQueue.length > 2) this.state.directionQueue.shift();\n  }\n\n  toggleAudio() {\n    void this.audio.toggle();\n  }\n\n  dispose() {\n    this.stopLoop();\n    this.audio.dispose();\n  }\n\n  rebuildBoard() {\n    this.currentSourceText = this.sourceProvider.nextSource({\n      width: this.boardSize.width,\n      height: this.boardSize.height\n    });\n    this.currentSourcePath = this.extractSourcePath(this.currentSourceText);\n\n    this.codeGrid = buildCodeGrid(\n      this.currentSourceText,\n      this.boardSize.width,\n      this.boardSize.height\n    );\n    this.styleGrid = buildStyleGrid(this.codeGrid, KEYWORDS);\n  }\n\n  computeBoardSize() {\n    const measured = this.renderer.measureBoardSize?.();\n    if (\n      measured &&\n      Number.isInteger(measured.width) &&\n      Number.isInteger(measured.height) &&\n      measured.width > 0 &&\n      measured.height > 0\n    ) {\n      return measured;\n    }\n    return { ...GRID };\n  }\n\n  updateLoopSpeed() {\n    const delayMs = Math.max(SPEED.minDelayMs, Math.floor(SPEED.baseDelayMs / this.state.speed));\n    this.stopLoop();\n    this.interval = setInterval(() => this.tick(), delayMs);\n  }\n\n  stopLoop() {\n    if (!this.interval) return;\n    clearInterval(this.interval);\n    this.interval = null;\n  }\n\n  syncHud() {\n    this.renderer.updateStatus({\n      score: this.state.score,\n      stage: this.state.stage,\n      targetChar: this.currentTargetLabel(),\n      avoidChars: this.currentAvoidLabel(),\n      eaten: this.state.eatenCount,\n      speed: this.state.speed,\n      audioEnabled: this.audio.isEnabled()\n    });\n  }\n\n  render() {\n    this.renderer.renderBoard({\n      codeGrid: this.codeGrid,\n      styleGrid: this.styleGrid,\n      eaten: this.state.eaten,\n      corruptedChars: this.state.corruptedChars,\n      activeTargets: this.state.activeTargets,\n      hazardCells: this.state.hazardCells,\n      snake: this.state.snake,\n      gameOver: this.state.gameOver,\n      won: this.state.won\n    });\n  }\n\n  tick() {\n    if (!this.state.running || this.state.gameOver) return;\n\n    const queued = this.state.directionQueue.shift();\n    if (queued) this.state.direction = queued;\n\n    const head = this.state.snake[0];\n    const next = {\n      x: head.x + this.state.direction.x,\n      y: head.y + this.state.direction.y\n    };\n\n    if (!inBounds(next.x, next.y, this.boardSize.width, this.boardSize.height)) {\n      this.endGame(false);\n      return;\n    }\n\n    if (this.collidesWithSnake(next.x, next.y)) {\n      this.endGame(false);\n      return;\n    }\n\n    const nextKey = cellKey(next.x, next.y);\n    if (this.state.eaten.has(nextKey)) {\n      this.endGame(false, false, true);\n      return;\n    }\n\n    if (this.state.hazardCells.has(nextKey)) {\n      this.endGame(false, true);\n      return;\n    }\n\n    this.state.snake.unshift(next);\n\n    let leveledUp = false;\n    if (this.state.activeTargets.has(nextKey)) {\n      leveledUp = this.eatTarget(nextKey);\n    } else if (this.state.growth > 0) {\n      this.state.growth -= 1;\n    } else {\n      this.state.snake.pop();\n    }\n\n    if (this.state.gameOver) {\n      this.syncHud();\n      this.render();\n      return;\n    }\n\n    this.refreshHazards();\n    this.syncHud();\n    if (!leveledUp) this.renderer.setMessage(this.progressMessage());\n    this.updateLoopSpeed();\n    this.render();\n  }\n\n  collidesWithSnake(x, y) {\n    for (let i = 0; i < this.state.snake.length; i += 1) {\n      const segment = this.state.snake[i];\n      if (segment.x === x && segment.y === y) return true;\n    }\n    return false;\n  }\n\n  eatTarget(cell) {\n    this.state.activeTargets.delete(cell);\n    this.state.eaten.add(cell);\n    this.state.corruptedChars.set(cell, this.randomCorruptionChar());\n    this.state.hazardCells.delete(cell);\n    this.state.eatenCount += 1;\n    this.state.eatenThisTarget += 1;\n    this.state.score += 12 + this.state.snake.length;\n    this.state.growth += 1;\n    this.state.speed = Math.min(\n      SPEED.maxMultiplier,\n      1 + this.state.eatenCount * SPEED.increasePerEat\n    );\n    this.audio.setGameSpeed(this.state.speed);\n\n    this.renderer.triggerGlitch();\n    this.audio.playEatSfx();\n\n    if (this.checkStageProgress()) return true;\n\n    if (this.state.eatenThisTarget >= this.state.targetQuota) {\n      this.pickNextTargets();\n      this.refreshHazards(true);\n      return false;\n    }\n\n    this.maybeRefreshTargets();\n    return false;\n  }\n\n  randomCorruptionChar() {\n    const idx = Math.floor(Math.random() * CORRUPTION_CHARS.length);\n    return CORRUPTION_CHARS[idx];\n  }\n\n  maybeRefreshTargets() {\n    if (this.state.activeTargets.size > 0) return;\n    this.pickNextTargets();\n  }\n\n  checkStageProgress() {\n    const nextStage = 1 + Math.floor(this.state.eatenCount / STAGES.corruptionsPerLevel);\n    if (nextStage <= this.state.stage) return false;\n\n    while (this.state.stage < nextStage && !this.state.gameOver) {\n      this.state.stage += 1;\n      this.advanceStage();\n    }\n\n    return true;\n  }\n\n  advanceStage() {\n    this.rebuildBoard();\n    this.state.activeTargets.clear();\n    this.state.hazardCells.clear();\n    this.state.activeHazardChars = [];\n    this.state.eatenThisTarget = 0;\n\n    const hasTargets = this.pickNextTargets();\n    if (!hasTargets) return;\n\n    this.refreshHazards(true);\n    this.renderer.triggerGlitch();\n    this.audio.playStartSfx();\n    this.renderer.setMessage(`Stage ${this.state.stage} breach. Injecting ${this.currentSourcePath}.`);\n  }\n\n  pickNextTargets() {\n    const charCount = Math.min(\n      TARGETS.maxChars,\n      TARGETS.minChars + Math.floor(this.state.eatenCount / TARGETS.charGrowthStep)\n    );\n\n    const selected = [];\n    for (let i = 0; i < TARGET_SEQUENCE.length && selected.length < charCount; i += 1) {\n      const idx = (this.state.currentTargetIndex + i) % TARGET_SEQUENCE.length;\n      const char = TARGET_SEQUENCE[idx];\n      const pool = collectTargetCandidates(this.codeGrid, char, this.state.eaten);\n      if (pool.length === 0) continue;\n      selected.push({ idx, char, pool });\n    }\n\n    if (selected.length === 0) {\n      this.state.won = true;\n      this.state.running = false;\n      this.state.gameOver = true;\n      this.stopLoop();\n      this.audio.setPlaybackActive(false);\n      this.renderer.setMessage(UI_TEXT.fullCorruptionReset);\n      return false;\n    }\n\n    const perCharCap = Math.min(\n      TARGETS.perCharMax,\n      TARGETS.perCharBase + Math.floor(this.state.score / TARGETS.perCharScoreStep)\n    );\n\n    const targetCells = new Set();\n    for (const item of selected) {\n      for (const cell of shuffled(item.pool).slice(0, perCharCap)) {\n        targetCells.add(cell);\n      }\n    }\n\n    this.state.activeTargetChars = selected.map((item) => item.char);\n    this.state.currentTargetIndex = (selected[selected.length - 1].idx + 1) % TARGET_SEQUENCE.length;\n    this.state.activeTargets = targetCells;\n    this.state.eatenThisTarget = 0;\n    this.state.targetQuota = Math.min(\n      TARGETS.maxQuota,\n      TARGETS.baseQuota + Math.floor(this.state.score / TARGETS.scoreStep)\n    );\n\n    return true;\n  }\n\n  desiredHazardCount() {\n    if (this.state.eatenCount < HAZARDS.unlockAtEaten) return 0;\n    const growth = Math.floor((this.state.eatenCount - HAZARDS.unlockAtEaten) / HAZARDS.growthStep);\n    return Math.min(HAZARDS.maxCount, HAZARDS.baseCount + growth * 3);\n  }\n\n  refreshHazards(forceReset = false) {\n    const desiredCount = this.desiredHazardCount();\n    if (desiredCount <= 0) {\n      this.state.hazardCells.clear();\n      this.state.activeHazardChars = [];\n      return;\n    }\n\n    if (forceReset) this.state.hazardCells.clear();\n\n    const snakeSet = new Set(this.state.snake.map((segment) => cellKey(segment.x, segment.y)));\n    const byChar = new Map();\n\n    for (const char of HAZARD_SEQUENCE) {\n      const candidates = collectTargetCandidates(this.codeGrid, char, this.state.eaten)\n        .filter((key) => !this.state.activeTargets.has(key))\n        .filter((key) => !snakeSet.has(key));\n\n      if (candidates.length > 0) byChar.set(char, shuffled(candidates));\n    }\n\n    this.state.activeHazardChars = [...byChar.keys()].slice(0, 4);\n\n    const validExisting = new Set();\n    for (const key of this.state.hazardCells) {\n      if (this.state.activeTargets.has(key) || this.state.eaten.has(key) || snakeSet.has(key)) continue;\n      const [x, y] = key.split(\",\").map(Number);\n      if (!inBounds(x, y, this.boardSize.width, this.boardSize.height)) continue;\n      validExisting.add(key);\n    }\n\n    this.state.hazardCells = validExisting;\n\n    const pools = [...byChar.values()];\n    let poolIndex = 0;\n    while (this.state.hazardCells.size < desiredCount && pools.length > 0) {\n      const pool = pools[poolIndex % pools.length];\n      const next = pool.pop();\n      if (next) this.state.hazardCells.add(next);\n      poolIndex += 1;\n\n      if (pool.length === 0) {\n        const idx = pools.indexOf(pool);\n        if (idx >= 0) pools.splice(idx, 1);\n      }\n    }\n  }\n\n  endGame(didWin, hitHazard = false, hitCorruption = false) {\n    this.state.running = false;\n    this.state.gameOver = true;\n    this.state.won = didWin;\n    this.stopLoop();\n    this.audio.setPlaybackActive(false);\n\n    if (!didWin) this.audio.playCrashSfx();\n\n    const message = didWin\n      ? UI_TEXT.fullCorruption\n      : (hitCorruption\n        ? UI_TEXT.corruptionCrash\n        : (hitHazard ? UI_TEXT.hazardCrash : UI_TEXT.crash));\n\n    this.renderer.setMessage(message);\n    this.render();\n  }\n\n  currentTargetLabel() {\n    if (this.state.activeTargetChars.length === 0) {\n      return TARGET_SEQUENCE[this.state.currentTargetIndex] || TARGET_SEQUENCE[0];\n    }\n\n    return this.state.activeTargetChars.join(\" \");\n  }\n\n  currentAvoidLabel() {\n    if (this.state.activeHazardChars.length === 0) return \"-\";\n    return this.state.activeHazardChars.join(\" \");\n  }\n\n  progressMessage() {\n    const target = this.currentTargetLabel();\n    const avoid = this.currentAvoidLabel();\n    return `Stage ${this.state.stage} | Corrupt [${target}] (${this.state.eatenThisTarget}/${this.state.targetQuota}). Avoid [${avoid}].`;\n  }\n\n  extractSourcePath(text) {\n    if (!text) return \"unknown.js\";\n    const firstLine = text.split(\"\\n\", 1)[0].trim();\n    if (!firstLine.startsWith(\"// source:\")) return \"unknown.js\";\n    const path = firstLine.slice(\"// source:\".length).trim();\n    return path || \"unknown.js\";\n  }\n}\n"
  },
  {
    "path": "src/game/game-state.js",
    "content": "import { START_DIRECTION } from \"./constants.js\";\n\nfunction createInitialSnake(width, height) {\n  const x = Math.floor(width / 2);\n  const y = Math.floor(height / 2);\n\n  return [\n    { x: x - 1, y },\n    { x: x - 2, y },\n    { x: x - 3, y }\n  ];\n}\n\nexport function createInitialState(width, height) {\n  return {\n    eaten: new Set(),\n    corruptedChars: new Map(),\n    snake: createInitialSnake(width, height),\n    direction: { ...START_DIRECTION },\n    queuedDirection: { ...START_DIRECTION },\n    directionQueue: [],\n    score: 0,\n    stage: 1,\n    eatenCount: 0,\n    currentTargetIndex: 0,\n    activeTargetChars: [],\n    targetQuota: 7,\n    eatenThisTarget: 0,\n    activeTargets: new Set(),\n    hazardCells: new Set(),\n    activeHazardChars: [],\n    growth: 0,\n    speed: 1,\n    running: false,\n    gameOver: false,\n    won: false\n  };\n}\n"
  },
  {
    "path": "src/game/grid.js",
    "content": "export function buildCodeGrid(sourceText, width, height) {\n  const lines = sourceText.split(\"\\n\").slice(0, height);\n  return Array.from({ length: height }, (_, y) => {\n    const base = (lines[y] || \"\").padEnd(width, \" \").slice(0, width);\n    return base.split(\"\");\n  });\n}\n\nexport function cellKey(x, y) {\n  return `${x},${y}`;\n}\n\nexport function inBounds(x, y, width, height) {\n  return x >= 0 && x < width && y >= 0 && y < height;\n}\n\nexport function shuffled(values) {\n  const copy = values.slice();\n  for (let i = copy.length - 1; i > 0; i -= 1) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [copy[i], copy[j]] = [copy[j], copy[i]];\n  }\n  return copy;\n}\n\nexport function collectTargetCandidates(codeGrid, char, eatenSet) {\n  const candidates = [];\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n\n  for (let y = 0; y < height; y += 1) {\n    for (let x = 0; x < width; x += 1) {\n      const key = cellKey(x, y);\n      if (eatenSet.has(key)) continue;\n      if (codeGrid[y][x] === char) candidates.push(key);\n    }\n  }\n\n  return candidates;\n}\n"
  },
  {
    "path": "src/game/input-controller.js",
    "content": "export function bindInput({ onDirection, onStart, onToggleAudio }) {\n  const handler = (event) => {\n    const key = event.key.toLowerCase();\n\n    if (key === \"arrowup\" || key === \"w\") {\n      event.preventDefault();\n      onDirection(0, -1);\n    }\n\n    if (key === \"arrowdown\" || key === \"s\") {\n      event.preventDefault();\n      onDirection(0, 1);\n    }\n\n    if (key === \"arrowleft\" || key === \"a\") {\n      event.preventDefault();\n      onDirection(-1, 0);\n    }\n\n    if (key === \"arrowright\" || key === \"d\") {\n      event.preventDefault();\n      onDirection(1, 0);\n    }\n\n    if (key === \" \" || key === \"enter\") {\n      event.preventDefault();\n      onStart();\n    }\n\n    if (key === \"m\") {\n      event.preventDefault();\n      onToggleAudio();\n    }\n  };\n\n  document.addEventListener(\"keydown\", handler);\n\n  return () => {\n    document.removeEventListener(\"keydown\", handler);\n  };\n}\n"
  },
  {
    "path": "src/game/renderer.js",
    "content": "import { cellKey } from \"./grid.js\";\n\nfunction cellContent(char) {\n  if (char === \" \") return \"&nbsp;\";\n  if (char === \"<\") return \"&lt;\";\n  if (char === \">\") return \"&gt;\";\n  if (char === \"&\") return \"&amp;\";\n  return char;\n}\n\nexport class Renderer {\n  constructor(elements) {\n    this.elements = elements;\n  }\n\n  measureBoardSize() {\n    const editor = this.elements.editor;\n    if (!editor) return null;\n\n    const computed = getComputedStyle(editor);\n    const paddingX = Number.parseFloat(computed.paddingLeft) + Number.parseFloat(computed.paddingRight);\n    const paddingY = Number.parseFloat(computed.paddingTop) + Number.parseFloat(computed.paddingBottom);\n\n    const probe = document.createElement(\"span\");\n    probe.className = \"cell\";\n    probe.style.position = \"absolute\";\n    probe.style.visibility = \"hidden\";\n    probe.style.pointerEvents = \"none\";\n    probe.textContent = \"M\";\n    editor.appendChild(probe);\n    const charRect = probe.getBoundingClientRect();\n    editor.removeChild(probe);\n\n    const charWidth = Math.max(1, Math.ceil(charRect.width));\n    const lineHeight = Math.max(\n      1,\n      Math.ceil(Number.parseFloat(computed.lineHeight) || charRect.height)\n    );\n\n    const gutterWidth = 42;\n    const usableWidth = Math.max(0, editor.clientWidth - paddingX - gutterWidth);\n    const usableHeight = Math.max(0, editor.clientHeight - paddingY);\n    return {\n      width: Math.max(24, Math.floor(usableWidth / charWidth)),\n      height: Math.max(12, Math.floor(usableHeight / lineHeight))\n    };\n  }\n\n  updateStatus({ score, stage, targetChar, avoidChars, eaten, speed, audioEnabled }) {\n    this.elements.score.textContent = String(score);\n    this.elements.stage.textContent = String(stage);\n    this.elements.targetChar.textContent = targetChar;\n    this.elements.avoidChars.textContent = avoidChars;\n    this.elements.eaten.textContent = String(eaten);\n    this.elements.speed.textContent = `${speed.toFixed(1)}x`;\n    this.updateAudioStatus(audioEnabled);\n  }\n\n  updateAudioStatus(enabled) {\n    this.elements.audioStatus.textContent = enabled ? \"ON\" : \"OFF\";\n  }\n\n  setMessage(message) {\n    this.elements.message.textContent = message;\n  }\n\n  triggerGlitch() {\n    this.elements.app.classList.remove(\"glitch\");\n    void this.elements.app.offsetWidth;\n    this.elements.app.classList.add(\"glitch\");\n    setTimeout(() => this.elements.app.classList.remove(\"glitch\"), 130);\n  }\n\n  renderBoard({\n    codeGrid,\n    styleGrid,\n    eaten,\n    corruptedChars,\n    activeTargets,\n    hazardCells,\n    snake,\n    gameOver,\n    won\n  }) {\n    const snakeSet = new Set(snake.map((segment) => cellKey(segment.x, segment.y)));\n    const headKey = snake[0] ? cellKey(snake[0].x, snake[0].y) : \"\";\n\n    const html = [];\n    for (let y = 0; y < codeGrid.length; y += 1) {\n      html.push(`<span class=\"line\"><span class=\"ln\">${String(y + 1).padStart(2, \"0\")}</span>`);\n\n      for (let x = 0; x < codeGrid[y].length; x += 1) {\n        const key = cellKey(x, y);\n        let char = codeGrid[y][x];\n        let className = `cell ${styleGrid[y][x]}`;\n\n        if (eaten.has(key)) {\n          char = corruptedChars.get(key) || \"#\";\n          className += \" corrupted\";\n        } else if (hazardCells.has(key)) {\n          className += \" hazard\";\n        } else if (activeTargets.has(key)) {\n          className += \" target\";\n        }\n\n        if (snakeSet.has(key)) className += \" virus\";\n        if (key === headKey) className += \" head\";\n        if (gameOver && !won && key === headKey) className += \" dead\";\n\n        html.push(`<span class=\"${className}\">${cellContent(char)}</span>`);\n      }\n\n      html.push(\"</span>\");\n    }\n\n    this.elements.editor.innerHTML = html.join(\"\");\n  }\n}\n"
  },
  {
    "path": "src/game/source-text.js",
    "content": "import { HAZARD_SEQUENCE, TARGET_SEQUENCE } from \"./constants.js\";\nimport { SOURCE_CORPUS } from \"./source-corpus.js\";\n\nconst INTEREST_CHARS = new Set([...TARGET_SEQUENCE, ...HAZARD_SEQUENCE]);\n\nfunction scoreContent(content) {\n  let score = 0;\n  for (let i = 0; i < content.length; i += 1) {\n    if (INTEREST_CHARS.has(content[i])) score += 1;\n  }\n  return score;\n}\n\nfunction normalizeCorpus(corpus) {\n  return corpus\n    .map((entry) => {\n      const lines = entry.content.split(\"\\n\");\n      return {\n        path: entry.path,\n        lines,\n        interestScore: scoreContent(entry.content)\n      };\n    })\n    .filter((entry) => entry.lines.length > 0);\n}\n\nexport class SourceTextProvider {\n  constructor(corpus = SOURCE_CORPUS) {\n    this.entries = normalizeCorpus(corpus);\n    this.lastPick = null;\n  }\n\n  nextSource({ width, height }) {\n    if (this.entries.length === 0) return \"\";\n\n    const viable = this.entries.filter((entry) => entry.interestScore >= 18);\n    const pool = viable.length > 0 ? viable : this.entries;\n    let index = Math.floor(Math.random() * pool.length);\n\n    if (pool.length > 1 && this.lastPick && pool[index].path === this.lastPick.path) {\n      index = (index + 1 + Math.floor(Math.random() * (pool.length - 1))) % pool.length;\n    }\n\n    const entry = pool[index];\n    const bodyLines = Math.max(1, height - 2);\n    const maxStart = Math.max(0, entry.lines.length - bodyLines);\n    let start = maxStart > 0 ? Math.floor(Math.random() * (maxStart + 1)) : 0;\n\n    if (\n      maxStart > 0 &&\n      this.lastPick &&\n      this.lastPick.path === entry.path &&\n      this.lastPick.start === start\n    ) {\n      start = (start + 1 + Math.floor(Math.random() * maxStart)) % (maxStart + 1);\n    }\n\n    const end = start + bodyLines;\n    const selected = entry.lines.slice(start, end);\n    const header = [\n      `// source: ${entry.path}`,\n      `// region: ${start + 1}-${Math.min(entry.lines.length, end)}`\n    ];\n\n    const clipped = selected.map((line) => line.slice(0, Math.max(8, width)));\n    this.lastPick = { path: entry.path, start };\n    return [...header, ...clipped].join(\"\\n\");\n  }\n}\n\n"
  },
  {
    "path": "src/game/syntax-highlighter.js",
    "content": "function paintRange(styles, start, end, className) {\n  for (let i = start; i < end && i < styles.length; i += 1) styles[i] = className;\n}\n\nexport function buildStyleGrid(codeGrid, keywords) {\n  const height = codeGrid.length;\n  const width = codeGrid[0] ? codeGrid[0].length : 0;\n  const styleGrid = Array.from({ length: height }, () =>\n    Array.from({ length: width }, () => \"ch\")\n  );\n\n  for (let y = 0; y < height; y += 1) {\n    const line = codeGrid[y].join(\"\");\n    const styles = styleGrid[y];\n    let i = 0;\n\n    while (i < width) {\n      const ch = line[i];\n      const next = i + 1 < width ? line[i + 1] : \"\";\n\n      if (ch === \"/\" && next === \"/\") {\n        paintRange(styles, i, width, \"tk-comment\");\n        break;\n      }\n\n      if (ch === \"'\" || ch === '\"' || ch === \"`\") {\n        const quote = ch;\n        let j = i + 1;\n\n        while (j < width) {\n          if (line[j] === \"\\\\\" && j + 1 < width) {\n            j += 2;\n            continue;\n          }\n          if (line[j] === quote) {\n            j += 1;\n            break;\n          }\n          j += 1;\n        }\n\n        paintRange(styles, i, j, \"tk-string\");\n        i = j;\n        continue;\n      }\n\n      if (/[0-9]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[0-9_.]/.test(line[j])) j += 1;\n        paintRange(styles, i, j, \"tk-number\");\n        i = j;\n        continue;\n      }\n\n      if (/[A-Za-z_$]/.test(ch)) {\n        let j = i + 1;\n        while (j < width && /[A-Za-z0-9_$]/.test(line[j])) j += 1;\n\n        const word = line.slice(i, j);\n        if (keywords.has(word)) {\n          paintRange(styles, i, j, \"tk-keyword\");\n        } else {\n          let lookahead = j;\n          while (lookahead < width && /\\s/.test(line[lookahead])) lookahead += 1;\n          if (lookahead < width && line[lookahead] === \"(\") {\n            paintRange(styles, i, j, \"tk-function\");\n          }\n        }\n\n        i = j;\n        continue;\n      }\n\n      if (\"{}[]();,.<>:+-*/=%!?&|\".includes(ch)) styles[i] = \"tk-punct\";\n      i += 1;\n    }\n  }\n\n  return styleGrid;\n}\n"
  },
  {
    "path": "src/main.js",
    "content": "import { AudioEngine } from \"./game/audio-engine.js\";\nimport { GameEngine } from \"./game/game-engine.js\";\nimport { bindInput } from \"./game/input-controller.js\";\nimport { Renderer } from \"./game/renderer.js\";\nimport { SourceTextProvider } from \"./game/source-text.js\";\n\nfunction requireElement(id) {\n  const element = document.getElementById(id);\n  if (!element) throw new Error(`Missing required element: #${id}`);\n  return element;\n}\n\nconst elements = {\n  app: requireElement(\"app\"),\n  editor: requireElement(\"editor\"),\n  score: requireElement(\"score\"),\n  stage: requireElement(\"stage\"),\n  targetChar: requireElement(\"targetChar\"),\n  avoidChars: requireElement(\"avoidChars\"),\n  eaten: requireElement(\"eaten\"),\n  speed: requireElement(\"speed\"),\n  audioStatus: requireElement(\"audioStatus\"),\n  message: requireElement(\"message\")\n};\n\nconst renderer = new Renderer(elements);\nconst audio = new AudioEngine((enabled) => renderer.updateAudioStatus(enabled));\nconst sourceProvider = new SourceTextProvider();\nconst game = new GameEngine({ renderer, audio, sourceProvider });\nconst introOverlay = requireElement(\"introOverlay\");\nconst introStart = requireElement(\"introStart\");\n\nlet introVisible = true;\n\nfunction dismissIntro() {\n  if (!introVisible) return;\n  introVisible = false;\n  introOverlay.classList.add(\"hidden\");\n}\n\nconst unbindInput = bindInput({\n  onDirection: (x, y) => game.setDirection(x, y),\n  onStart: () => {\n    dismissIntro();\n    game.start();\n  },\n  onToggleAudio: () => game.toggleAudio()\n});\n\nintroStart.addEventListener(\"click\", () => {\n  dismissIntro();\n  game.start();\n});\n\ngame.reset();\n\nwindow.addEventListener(\"beforeunload\", () => {\n  unbindInput();\n  game.dispose();\n});\n"
  },
  {
    "path": "tests/game-engine.test.js",
    "content": "import { jest } from \"@jest/globals\";\nimport { HAZARDS, STAGES, UI_TEXT } from \"../src/game/constants.js\";\nimport { GameEngine } from \"../src/game/game-engine.js\";\nimport { cellKey } from \"../src/game/grid.js\";\n\nfunction buildSource(lines = 30) {\n  const row = \"{ } ( ) [ ] ; = < > function run() { return 42; } // comment\";\n  return Array.from({ length: lines }, () => row).join(\"\\n\");\n}\n\nfunction createRendererMock({ measuredBoardSize = null } = {}) {\n  return {\n    updateStatus: jest.fn(),\n    updateAudioStatus: jest.fn(),\n    setMessage: jest.fn(),\n    renderBoard: jest.fn(),\n    triggerGlitch: jest.fn(),\n    measureBoardSize: jest.fn(() => measuredBoardSize)\n  };\n}\n\nfunction createAudioMock({ enabled = true } = {}) {\n  return {\n    isEnabled: jest.fn(() => enabled),\n    ensureEnabledForGameplay: jest.fn(() => Promise.resolve()),\n    toggle: jest.fn(() => Promise.resolve()),\n    setPlaybackActive: jest.fn(),\n    setGameSpeed: jest.fn(),\n    dispose: jest.fn(),\n    playStartSfx: jest.fn(),\n    playEatSfx: jest.fn(),\n    playCrashSfx: jest.fn()\n  };\n}\n\nfunction createEngine(options = {}) {\n  const renderer = createRendererMock({\n    measuredBoardSize: options.measuredBoardSize ?? null\n  });\n  const audio = createAudioMock({ enabled: options.audioEnabled ?? true });\n  const engine = new GameEngine({\n    renderer,\n    audio,\n    sourceProvider: options.sourceProvider,\n    sourceText: options.sourceText ?? buildSource()\n  });\n\n  return { engine, renderer, audio };\n}\n\ndescribe(\"GameEngine\", () => {\n  beforeEach(() => {\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  test(\"reset initializes board, HUD, and ready message\", () => {\n    const { engine, renderer } = createEngine();\n\n    engine.reset();\n\n    expect(engine.state.running).toBe(false);\n    expect(engine.state.gameOver).toBe(false);\n    expect(engine.state.activeTargets.size).toBeGreaterThan(0);\n\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.ready);\n    expect(renderer.updateStatus).toHaveBeenCalled();\n    expect(renderer.renderBoard).toHaveBeenCalled();\n\n    const lastHud = renderer.updateStatus.mock.calls.at(-1)[0];\n    expect(lastHud.stage).toBe(1);\n    expect(lastHud.targetChar.length).toBeGreaterThan(0);\n    expect(lastHud.targetChar).toContain(\"{\");\n  });\n\n  test(\"reset uses renderer-measured board size when available\", () => {\n    const { engine } = createEngine({ measuredBoardSize: { width: 40, height: 18 } });\n\n    engine.reset();\n\n    expect(engine.boardSize).toEqual({ width: 40, height: 18 });\n    expect(engine.codeGrid.length).toBe(18);\n    expect(engine.codeGrid[0].length).toBe(40);\n  });\n\n  test(\"uses custom source provider when supplied\", () => {\n    const sourceProvider = { nextSource: jest.fn(() => \"{ provider-source }\") };\n    const { engine } = createEngine({ sourceProvider });\n\n    engine.reset();\n\n    expect(sourceProvider.nextSource).toHaveBeenCalled();\n    expect(engine.currentSourceText).toContain(\"provider-source\");\n  });\n\n  test(\"start begins loop and triggers start SFX\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.start();\n\n    expect(engine.state.running).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(true);\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(audio.playStartSfx).toHaveBeenCalledTimes(1);\n    expect(jest.getTimerCount()).toBeGreaterThan(0);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toMatch(/^Stage 1 \\| Corrupt/);\n  });\n\n  test(\"stopLoop clears the active loop interval\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n    engine.start();\n    expect(engine.interval).not.toBeNull();\n\n    engine.stopLoop();\n    expect(engine.interval).toBeNull();\n  });\n\n  test(\"start asks audio engine to enable when currently disabled\", () => {\n    const { engine, audio } = createEngine({ audioEnabled: false });\n    engine.reset();\n\n    engine.start();\n\n    expect(audio.ensureEnabledForGameplay).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"setDirection queues rapid turns and blocks reversals\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([]);\n\n    engine.setDirection(0, -1);\n    engine.setDirection(-1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n\n    engine.setDirection(1, 0);\n    expect(engine.state.directionQueue).toEqual([{ x: 0, y: -1 }, { x: -1, y: 0 }]);\n  });\n\n  test(\"tick ends the game on wall collision\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 0, y: 0 }];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.crash);\n  });\n\n  test(\"tick ends the game on self-collision\", () => {\n    const { engine, audio } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [\n      { x: 2, y: 2 },\n      { x: 3, y: 2 },\n      { x: 3, y: 3 },\n      { x: 2, y: 3 }\n    ];\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(audio.playCrashSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"tick consumes target cells and updates progression state\", () => {\n    const { engine, audio, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.queuedDirection = { x: 1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n\n    const oldScore = engine.state.score;\n    const oldLength = engine.state.snake.length;\n\n    engine.tick();\n\n    expect(engine.state.eaten.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.corruptedChars.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.eatenCount).toBe(1);\n    expect(engine.state.eatenThisTarget).toBeGreaterThanOrEqual(0);\n    expect(engine.state.score).toBeGreaterThan(oldScore);\n    expect(engine.state.speed).toBeGreaterThan(1);\n    expect(engine.state.snake.length).toBe(oldLength + 1);\n\n    expect(audio.setGameSpeed).toHaveBeenCalledWith(engine.state.speed);\n    expect(renderer.triggerGlitch).toHaveBeenCalledTimes(1);\n    expect(audio.playEatSfx).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"corruption threshold level-up advances stage and swaps code source\", () => {\n    const sourceProvider = {\n      nextSource: jest.fn()\n        .mockReturnValueOnce(\n          \"// source: alpha.js\\n// region: 1-8\\n{ } ( ) [ ] ; = < > a e i o u s r t n l c d m f\"\n        )\n        .mockReturnValueOnce(\n          \"// source: beta.js\\n// region: 1-8\\nfunction beta(){return safe_token + glitch_mask;}\"\n        )\n    };\n    const { engine } = createEngine({\n      measuredBoardSize: { width: 24, height: 12 },\n      sourceProvider\n    });\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n    engine.state.eatenCount = STAGES.corruptionsPerLevel - 1;\n\n    engine.tick();\n\n    expect(engine.state.stage).toBe(2);\n    expect(sourceProvider.nextSource).toHaveBeenCalledTimes(2);\n    expect(engine.currentSourcePath).toBe(\"beta.js\");\n    expect(engine.state.activeTargets.size).toBeGreaterThan(0);\n    expect(engine.state.eaten.has(cellKey(2, 1))).toBe(true);\n    expect(engine.state.corruptedChars.has(cellKey(2, 1))).toBe(true);\n  });\n\n  test(\"tick decrements growth on empty movement and keeps tail length\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 1;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.growth).toBe(0);\n    expect(engine.state.snake.length).toBe(beforeLength + 1);\n  });\n\n  test(\"tick pops tail on empty movement when no growth remains\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 5, y: 5 }, { x: 4, y: 5 }, { x: 3, y: 5 }];\n    engine.state.activeTargets = new Set();\n    engine.state.growth = 0;\n\n    const beforeLength = engine.state.snake.length;\n    engine.tick();\n\n    expect(engine.state.snake.length).toBe(beforeLength);\n  });\n\n  test(\"consuming the final quota target rotates to the next target set\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 1, y: 1 }, { x: 0, y: 1 }];\n    engine.state.activeTargets = new Set([cellKey(2, 1)]);\n    engine.state.targetQuota = 1;\n    engine.state.eatenThisTarget = 0;\n    const previousTarget = engine.state.currentTargetIndex;\n\n    engine.tick();\n\n    expect(engine.state.currentTargetIndex).not.toBe(previousTarget);\n    expect(engine.state.eatenThisTarget).toBe(0);\n  });\n\n  test(\"pickNextTargets reports full corruption when no targets remain\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.eaten.add(\"0,0\");\n    engine.state.activeTargets.clear();\n\n    const found = engine.pickNextTargets();\n\n    expect(found).toBe(false);\n    expect(engine.state.gameOver).toBe(true);\n    expect(engine.state.won).toBe(true);\n    expect(engine.audio.setPlaybackActive).toHaveBeenCalledWith(false);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"hazard collision ends game with hazard-specific message\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 2, y: 2 }];\n    engine.state.hazardCells = new Set([cellKey(3, 2)]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.hazardCrash);\n  });\n\n  test(\"collision with corrupted code ends game with corruption-specific message\", () => {\n    const { engine, renderer } = createEngine();\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: 1, y: 0 };\n    engine.state.directionQueue = [];\n    engine.state.snake = [{ x: 4, y: 4 }];\n    engine.state.eaten = new Set([cellKey(5, 4)]);\n    engine.state.corruptedChars.set(cellKey(5, 4), \"#\");\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage).toHaveBeenCalledWith(UI_TEXT.corruptionCrash);\n  });\n\n  test(\"refreshHazards creates avoid cells as progression increases\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = HAZARDS.unlockAtEaten + HAZARDS.growthStep * 2;\n    engine.state.activeTargets = new Set();\n    engine.state.hazardCells = new Set([\"0,0\"]);\n    engine.state.snake = [{ x: 10, y: 10 }];\n\n    engine.refreshHazards(true);\n\n    expect(engine.state.activeHazardChars.length).toBeGreaterThan(0);\n    expect(engine.state.hazardCells.size).toBeGreaterThan(0);\n  });\n\n  test(\"refreshHazards clears existing hazards when below unlock threshold\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.eatenCount = 0;\n    engine.state.hazardCells = new Set([\"1,1\", \"2,2\"]);\n    engine.state.activeHazardChars = [\":\", \".\"];\n\n    engine.refreshHazards();\n\n    expect(engine.state.hazardCells.size).toBe(0);\n    expect(engine.state.activeHazardChars).toEqual([]);\n  });\n\n  test(\"label helpers handle empty and populated states\", () => {\n    const { engine } = createEngine();\n    engine.reset();\n\n    engine.state.activeTargetChars = [];\n    engine.state.currentTargetIndex = 0;\n    expect(engine.currentTargetLabel()).toBe(\"{\");\n\n    engine.state.activeHazardChars = [];\n    expect(engine.currentAvoidLabel()).toBe(\"-\");\n\n    engine.state.activeTargetChars = [\"{\", \"}\", \";\"];\n    engine.state.activeHazardChars = [\":\", \".\"];\n    expect(engine.currentTargetLabel()).toBe(\"{ } ;\");\n    expect(engine.currentAvoidLabel()).toBe(\": .\");\n  });\n\n  test(\"tick keeps full-corruption message when terminal state happens mid-tick\", () => {\n    const { engine, renderer } = createEngine({ sourceText: \"{\" });\n    engine.reset();\n\n    engine.state.running = true;\n    engine.state.direction = { x: -1, y: 0 };\n    engine.state.queuedDirection = { x: -1, y: 0 };\n    engine.state.snake = [{ x: 1, y: 0 }];\n    engine.state.activeTargets = new Set([\"0,0\"]);\n\n    engine.tick();\n\n    expect(engine.state.gameOver).toBe(true);\n    expect(renderer.setMessage.mock.calls.at(-1)[0]).toBe(UI_TEXT.fullCorruptionReset);\n  });\n\n  test(\"toggleAudio and dispose delegate to audio engine\", () => {\n    const { engine, audio } = createEngine();\n\n    engine.toggleAudio();\n    engine.dispose();\n\n    expect(audio.toggle).toHaveBeenCalledTimes(1);\n    expect(audio.dispose).toHaveBeenCalledTimes(1);\n  });\n});\n"
  },
  {
    "path": "tests/game-state.test.js",
    "content": "import { START_DIRECTION } from \"../src/game/constants.js\";\nimport { createInitialState } from \"../src/game/game-state.js\";\n\ndescribe(\"createInitialState\", () => {\n  test(\"creates expected defaults and centered snake\", () => {\n    const state = createInitialState(20, 10);\n\n    expect(state.score).toBe(0);\n    expect(state.stage).toBe(1);\n    expect(state.eatenCount).toBe(0);\n    expect(state.speed).toBe(1);\n    expect(state.running).toBe(false);\n    expect(state.gameOver).toBe(false);\n    expect(state.won).toBe(false);\n\n    expect(state.direction).toEqual(START_DIRECTION);\n    expect(state.queuedDirection).toEqual(START_DIRECTION);\n    expect(state.directionQueue).toEqual([]);\n    expect(state.corruptedChars.size).toBe(0);\n    expect(state.snake).toEqual([\n      { x: 9, y: 5 },\n      { x: 8, y: 5 },\n      { x: 7, y: 5 }\n    ]);\n  });\n\n  test(\"returns fresh mutable collections per call\", () => {\n    const a = createInitialState(20, 10);\n    const b = createInitialState(20, 10);\n\n    a.eaten.add(\"1,1\");\n    a.corruptedChars.set(\"1,1\", \"#\");\n    a.activeTargets.add(\"2,2\");\n    a.direction.x = 999;\n\n    expect(b.eaten.size).toBe(0);\n    expect(b.corruptedChars.size).toBe(0);\n    expect(b.activeTargets.size).toBe(0);\n    expect(b.direction).toEqual(START_DIRECTION);\n  });\n});\n"
  },
  {
    "path": "tests/grid.test.js",
    "content": "import {\n  buildCodeGrid,\n  cellKey,\n  collectTargetCandidates,\n  inBounds,\n  shuffled\n} from \"../src/game/grid.js\";\n\ndescribe(\"grid utilities\", () => {\n  test(\"buildCodeGrid pads and truncates lines to requested dimensions\", () => {\n    const grid = buildCodeGrid(\"abc\\nlonger-than-width\\n\", 5, 3);\n\n    expect(grid).toEqual([\n      [\"a\", \"b\", \"c\", \" \", \" \"],\n      [\"l\", \"o\", \"n\", \"g\", \"e\"],\n      [\" \", \" \", \" \", \" \", \" \"]\n    ]);\n  });\n\n  test(\"cellKey creates stable key strings\", () => {\n    expect(cellKey(10, 4)).toBe(\"10,4\");\n  });\n\n  test(\"inBounds checks coordinates correctly\", () => {\n    expect(inBounds(0, 0, 3, 3)).toBe(true);\n    expect(inBounds(2, 2, 3, 3)).toBe(true);\n    expect(inBounds(-1, 0, 3, 3)).toBe(false);\n    expect(inBounds(0, 3, 3, 3)).toBe(false);\n    expect(inBounds(3, 0, 3, 3)).toBe(false);\n  });\n\n  test(\"shuffled returns a new array with same values\", () => {\n    const input = [\"a\", \"b\", \"c\", \"d\"];\n    const result = shuffled(input);\n\n    expect(result).not.toBe(input);\n    expect(result.slice().sort()).toEqual(input.slice().sort());\n  });\n\n  test(\"collectTargetCandidates returns only non-eaten matches\", () => {\n    const grid = [\n      [\"{\", \"x\", \"{\"],\n      [\"}\", \"{\", \"y\"]\n    ];\n    const eaten = new Set([\"2,0\"]);\n\n    expect(collectTargetCandidates(grid, \"{\", eaten).sort()).toEqual([\"0,0\", \"1,1\"]);\n    expect(collectTargetCandidates(grid, \"}\", eaten)).toEqual([\"0,1\"]);\n  });\n});\n"
  },
  {
    "path": "tests/source-text.test.js",
    "content": "import { SourceTextProvider } from \"../src/game/source-text.js\";\n\ndescribe(\"SourceTextProvider\", () => {\n  test(\"returns source text windows with metadata header\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"one\\ntwo\\nthree\\nfour\" }\n    ]);\n\n    const snippet = provider.nextSource({ width: 80, height: 4 });\n    const lines = snippet.split(\"\\n\");\n\n    expect(lines[0]).toMatch(/^\\/\\/ source: a\\.js/);\n    expect(lines[1]).toMatch(/^\\/\\/ region: /);\n    expect(lines.length).toBe(4);\n  });\n\n  test(\"avoids repeating identical pick when multiple corpus entries exist\", () => {\n    const provider = new SourceTextProvider([\n      { path: \"a.js\", content: \"alpha\\nbeta\\ngamma\" },\n      { path: \"b.js\", content: \"delta\\nepsilon\\nzeta\" }\n    ]);\n\n    const first = provider.nextSource({ width: 80, height: 4 });\n    const second = provider.nextSource({ width: 80, height: 4 });\n\n    expect(first).not.toBe(second);\n  });\n});\n"
  },
  {
    "path": "tests/syntax-highlighter.test.js",
    "content": "import { KEYWORDS } from \"../src/game/constants.js\";\nimport { buildStyleGrid } from \"../src/game/syntax-highlighter.js\";\n\nfunction lineToGrid(line) {\n  return [line.split(\"\")];\n}\n\ndescribe(\"buildStyleGrid\", () => {\n  test(\"highlights keywords and function identifiers\", () => {\n    const line = \"const run = move();\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles.slice(0, 5).every((s) => s === \"tk-keyword\")).toBe(true);\n    expect(styles[line.indexOf(\"move\")]).toBe(\"tk-function\");\n  });\n\n  test(\"highlights strings and numbers\", () => {\n    const line = \"let value = \\\"hi\\\" + 10_5;\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"let\")]).toBe(\"tk-keyword\");\n    expect(styles[line.indexOf('\"')]).toBe(\"tk-string\");\n    expect(styles[line.indexOf(\"1\")]).toBe(\"tk-number\");\n  });\n\n  test(\"highlights comments until line end\", () => {\n    const line = \"x = 2; // todo\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n    const commentStart = line.indexOf(\"//\");\n\n    expect(styles[commentStart]).toBe(\"tk-comment\");\n    expect(styles.slice(commentStart).every((s) => s === \"tk-comment\")).toBe(true);\n  });\n\n  test(\"marks punctuation tokens\", () => {\n    const line = \"{ a: (b + c) }\";\n    const [styles] = buildStyleGrid(lineToGrid(line), KEYWORDS);\n\n    expect(styles[line.indexOf(\"{\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\":\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\"+\")]).toBe(\"tk-punct\");\n    expect(styles[line.indexOf(\")\")]).toBe(\"tk-punct\");\n  });\n});\n"
  }
];
